import{_ as n,c as a,e as p,o as e}from"./app-DWx6AsHO.js";const t={};function c(l,s){return e(),a("div",null,s[0]||(s[0]=[p(`<h1 id="_1-泛型程序设计" tabindex="-1"><a class="header-anchor" href="#_1-泛型程序设计"><span>1 泛型程序设计</span></a></h1><h2 id="_1-1-为什么要使用泛型程序设计" tabindex="-1"><a class="header-anchor" href="#_1-1-为什么要使用泛型程序设计"><span>1.1 为什么要使用泛型程序设计</span></a></h2><p>泛型程序设计意味着编写的代码可以对多种不同类型的对象重用。</p><p>在Java增加泛型类之前，泛型程序设计是用继承实现的，例如 <code>ArrayList</code> 类只维护一个 <code>Object</code> 引用的数组。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用这种方法存在两个问题：</p><ol><li>获取值时必须进行强制类型转换，在这里将 <code>Object</code> 类型强制转换为其他类型不会报错，但是在其他地方不能这样转换。</li><li>没有错误检查。例如可以向数组列表中添加任意类型的值。</li></ol><p>泛型提供了类型参数，可以用来指示元素的类型，这使得代码有更好的可读性，也便于编译器了解并利用类型信息。例如获取数组列表中的元素的值时不再需要进行强制类型转换，其实是编译器会自动添加这个类型转换；并且编译器会禁止添加与参数类型不符的元素，并返回编译错误。</p><p>泛型程序设计可以分为三个能力水平：</p><ol><li>仅仅使用泛型类，不考虑工作原理。</li><li>对泛型有充分的了解，能够系统解决使用泛型类时出现的问题。</li><li>实现泛型类和泛型方法。</li></ol><p>事实上泛型在应用程序开发时并不会很常用，学习泛型主要还是用于了解泛型的工作原理，并能够排除代码的问题。</p><h2 id="_1-2-定义简单泛型类" tabindex="-1"><a class="header-anchor" href="#_1-2-定义简单泛型类"><span>1.2 定义简单泛型类</span></a></h2><p>泛型类就是有一个或多个类型变量的类，将类型变量用尖括号括起来放在类名的后面。</p><p>类型变量是放在整个类定义中用于指定方法的返回类型以及字段和局部变量的类型。</p><p>可以用具体的类型来实例化泛型类型。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">T</span> first<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">U</span> second<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        first <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">        second <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token class-name">T</span> first<span class="token punctuation">,</span> <span class="token class-name">U</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> first<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">U</span> <span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> second<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirst</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        first <span class="token operator">=</span> value<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSecond</span><span class="token punctuation">(</span><span class="token class-name">U</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        second <span class="token operator">=</span> value<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_1-3-泛型方法" tabindex="-1"><a class="header-anchor" href="#_1-3-泛型方法"><span>1.3 泛型方法</span></a></h2><p>可以在普通类中定义泛型方法，也可以在泛型类中定义泛型方法。类型变量放在修饰符之后和返回类型之前。</p><p>调用泛型方法时，可以把具体类型包围在尖括号中，放在方法名的前面。大多数情况下可以省略类型参数，编译器会自动推断。偶尔自动类型推断会出现错误，比如解析的二义性，所以这种情况下最好显式指定参数类型。</p><p>如果想要知道编译器对一个泛型方法调用最终推断出哪种类型，可以故意引入一个错误，然后研究返回的错误消息。</p><p>C++中调用泛型方法时，类型参数放在方法名的后面，但这样容易产生解析二义性，所以将类型参数放在方法名的前面是一个明智的选择。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">TestClass</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">listMax</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_1-4-类型变量的限定" tabindex="-1"><a class="header-anchor" href="#_1-4-类型变量的限定"><span>1.4 类型变量的限定</span></a></h2><p>有时类或方法需要对类型变量加以限制，可以通过对类型变量设置限定来实现</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这样就只能在实现了 <code>Comparable</code> 接口的类的数组上使用该方法，类似于C++20标准中的 <code>concept</code> 和 <code>requires</code> 语法。</p><p>在这里 <code>T</code> 和限定类型可以是类也可以是接口，限定类型用 <code>&amp;</code> 分隔，类型变量用逗号分隔。</p><p>可以有多个限定，但最多只有一个限定可以是类，如果有一个类作为限定，它必须是限定列表中的第一个限定。</p><h2 id="_1-5-泛型代码和虚拟机" tabindex="-1"><a class="header-anchor" href="#_1-5-泛型代码和虚拟机"><span>1.5 泛型代码和虚拟机</span></a></h2><p>不同于C++泛型的模板类，Java的泛型使用的是类型擦除，将所有的类型变量都替换为限定类型或 <code>Object</code> 类型，在必要的时候通过强制类型转换转换为需要的类型，这样操作避免了模板展开带来的代码体积过大的问题，但是也导致了Java泛型的局限性；而C++通过模板展开，为每一种类型参数的实例单独生成一套代码，本质上是一种宏替换。</p><p>这两种不同的实现造成了泛型的不同特性。</p><h3 id="_1-5-1-类型擦除" tabindex="-1"><a class="header-anchor" href="#_1-5-1-类型擦除"><span>1.5.1 类型擦除</span></a></h3><p>定义泛型类型之后，会自动提供相应的原始类型，这个原始类型的名字就是去掉类型参数之后的泛型类型名。类型变量会被擦除，替换为其限定类型或 <code>Object</code> 类型。</p><p>对于同一个泛型类，无论在程序中包含哪种类型的该类，都会变成原始类型。比如前面的 <code>Pair&lt;T,U&gt;</code> 类，类 <code>Pair&lt;Integer,Double&gt;</code> 和 <code>Pair&lt;String,boolean&gt;</code> 等本质上都是相同的。</p><p>由于类型擦除时会用第一个限定类型替换泛型类型，所以为了提高效率，应该将标记接口，也就是没有方法的接口，放在限定列表的末尾。</p><h3 id="_1-5-2-转换泛型表达式" tabindex="-1"><a class="header-anchor" href="#_1-5-2-转换泛型表达式"><span>1.5.2 转换泛型表达式</span></a></h3><p>编写一个泛型方法调用时，如果擦除了返回类型，编译器会插入强制类型转换。</p><p>访问一个字段时也会插入强制类型转换。</p><h3 id="_1-5-3-转换泛型方法" tabindex="-1"><a class="header-anchor" href="#_1-5-3-转换泛型方法"><span>1.5.3 转换泛型方法</span></a></h3><p>编译器会利用桥方法解决泛型方法调用问题。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">T</span> first<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">T</span> second<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSecond</span><span class="token punctuation">(</span><span class="token class-name">T</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">DateInterval</span> <span class="token keyword">extends</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LocalDate</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSecond</span><span class="token punctuation">(</span><span class="token class-name">LocalDate</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">setSecond</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">LocalDate</span> <span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们希望覆盖泛型超类中的两个方法，但是现在从超类中继承的方法实际上是</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSecond</span><span class="token punctuation">(</span><span class="token class-name">Object</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>对于第一个方法，由于这两个方法的签名并不相同，实际上是无法覆盖的。这里我们希望该调用具有多态性，应该调用适当的方法，但是类型擦除和多态产生了冲突。为此，编译器在子类中生成了一个桥方法，现在子类中有两个相关方法</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSecond</span><span class="token punctuation">(</span><span class="token class-name">LocalDate</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSecond</span><span class="token punctuation">(</span><span class="token class-name">Object</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setSecond</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">LocalDate</span><span class="token punctuation">)</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于第二个方法，编译器会生成如下两个方法</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">LocalDate</span> <span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">LocalDate</span><span class="token punctuation">)</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编写程序时，两个方法只有返回类型不同是不合法的；但是在虚拟机中，会由参数类型和返回类型共同指定一个方法，虚拟机可以正确处理这种情况。其实，这就是协变返回类型的编译时操作。</p><p>对于Java泛型的转换，需要记住以下几点：</p><ol><li>虚拟机中没有泛型，只有普通的类和方法。</li><li>所有的类型参数都会替换为它们的限定类型。</li><li>会合成桥方法保持多态。</li><li>为保持类型安全性，会在必要时添加强制类型转换。</li></ol><h3 id="_1-5-4-调用遗留代码" tabindex="-1"><a class="header-anchor" href="#_1-5-4-调用遗留代码"><span>1.5.4 调用遗留代码</span></a></h3><p>设计Java泛型时，需要注意允许泛型代码和遗留代码之间能够互操作。</p><p>比如将泛型类的对象传递给遗留代码中的原始类变量时，或者将遗留代码中的原始类对象赋值给泛型类的变量时，编译器会发出警告。如果经过检查认为不会产生严重问题，可以使用 <code>@SuppressWarnings</code> 注解让警告消失。</p><h2 id="_1-6-限制与局限性" tabindex="-1"><a class="header-anchor" href="#_1-6-限制与局限性"><span>1.6 限制与局限性</span></a></h2><p>事实上，大多数限制都是由类型擦除引起的。</p><h3 id="_1-6-1-不能用基本类型实例化类型参数" tabindex="-1"><a class="header-anchor" href="#_1-6-1-不能用基本类型实例化类型参数"><span>1.6.1 不能用基本类型实例化类型参数</span></a></h3><p>类类型的变量不能引用基本类型，所以不能用基本类型实例化类型参数。如果一定要使用相关类和方法，可以使用包装器类型，或者使用针对基本类型特例化的类和方法。</p><h3 id="_1-6-2-运行时类型查询只适用于原始类型" tabindex="-1"><a class="header-anchor" href="#_1-6-2-运行时类型查询只适用于原始类型"><span>1.6.2 运行时类型查询只适用于原始类型</span></a></h3><p>虚拟机中的对象总是有一个特定的非泛型类型，所有的类型查询只生成原始类型，使用强制类型转换时也只能测试是否为原始类型的对象。如果试图查询某个对象是否属于某个泛型类型，使用 <code>instanceof</code> 会得到编译错误，使用强制类型转换会得到警告。</p><p>同样 <code>getClass</code> 方法总是返回原始类型。</p><h3 id="_1-6-3-不能创建参数化类型的数组" tabindex="-1"><a class="header-anchor" href="#_1-6-3-不能创建参数化类型的数组"><span>1.6.3 不能创建参数化类型的数组</span></a></h3><p>不能实例化参数化类型的数组。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">var</span> table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> objArray <span class="token operator">=</span> table<span class="token punctuation">;</span></span>
<span class="line">objArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种操作能够通过数组存储的类型检查，但是仍会导致类型错误，所以不允许创建参数化类型的数组。</p><p>但是声明类型为 <code>Pair&lt;String&gt;[]</code> 的变量是合法的，只不过不能使用 <code>new Pair&lt;String&gt;[10]</code> 初始化这个变量。</p><p>可以声明通配类型的数组，然后进行强制类型转换：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">var</span> table <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>但是这样的结果是不安全的，如果存入不合适的类型，有可能在方法调用时抛出异常。</p><p>如果需要收集参数化类型对象，可以直接使用 <code>ArrayList&lt;Pair&lt;String&gt;&gt;</code> 安全且有效。</p><h3 id="_1-6-4-varargs警告" tabindex="-1"><a class="header-anchor" href="#_1-6-4-varargs警告"><span>1.6.4 Varargs警告</span></a></h3><p>如果向参数个数可变的方法传递泛型类型，例如：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> coll<span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> ts<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">T</span> t <span class="token operator">:</span> ts<span class="token punctuation">)</span> coll<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了调用这个方法，虚拟机需要创建一个参数化类型的数组，在这种情况下只会得到警告而不是错误。</p><p>可以使用两种方法抑制这个警告：</p><ol><li>为包含 <code>addAll</code> 调用的方法增加注解 <code>@SuppressWarnings(&quot;unchecked&quot;)</code> 。</li><li>用 <code>@SafeVarargs</code> 直接注解 <code>addAll</code> 方法。</li></ol><p>对于任何只需要读取参数数组元素的方法都可以使用这个注解。</p><p>注意 <code>@SafeVarargs</code> 注解只能用于声明 <code>static</code> <code>final</code> 或 <code>private</code> 的构造器和方法。所有其他方法都有可能被覆盖，这会让这个注解失去意义。</p><p>可以使用这种技巧消除创建泛型数组的限制，但是这样做并不安全，有可能在其他地方得到异常。</p><h3 id="_1-6-5-不能实例化类型变量" tabindex="-1"><a class="header-anchor" href="#_1-6-5-不能实例化类型变量"><span>1.6.5 不能实例化类型变量</span></a></h3><p>不能在类似 <code>new T(...)</code> 的表达式中使用类型变量。</p><p>最好的解决办法是让调用者提供一个构造器表达式，比如通过 <code>Supplier&lt;T&gt;</code> 函数式接口接收。</p><p>比较传统的解决方法是通过反射调用 <code>Constructor.newInstance</code> 方法来构造泛型对象，但是需要适当地设计API得到 <code>Class</code> 对象。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// solution one</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">makePair</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> constr<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>constr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> constr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token comment">// solution two</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">makePair</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> cl<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>cl<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cl<span class="token punctuation">.</span><span class="token function">getConstuctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意 <code>Class</code> 类本身是泛型的，因此 <code>makePair</code> 方法能推断出准确的类型。</p><h3 id="_1-6-6-不能构造泛型数组" tabindex="-1"><a class="header-anchor" href="#_1-6-6-不能构造泛型数组"><span>1.6.6 不能构造泛型数组</span></a></h3><p>前面提到不能创建参数化类型的数组，但那是为了避免出现错误而被禁止操作。这里不能构造泛型数组，但是由于类型信息会被擦除，所以创建的实际上是原始类型的数组，返回的数组强制转换时抛出出现 <code>ClassCastException</code> 异常。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">min_max</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// var result = new T[2];</span></span>
<span class="line">    <span class="token comment">// ERROR</span></span>
<span class="line">    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// the real cast</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> result<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> names <span class="token operator">=</span> <span class="token function">min_max</span><span class="token punctuation">(</span><span class="token string">&quot;Tom&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Dick&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Harry&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码在编译时不会有任何警告，但是返回数组引用强制转换时就会出现异常。</p><p>所以，需要构建数组时最好让用户提供一个数组构造器表达式，方法会使用这个参数生成一个有正确类型的数组。</p><p>老式的方法是利用反射，并调用 <code>Array.newInstance</code> 方法。</p><p>而 <code>ArrayList</code> 的 <code>toArray</code> 方法需要生成一个 <code>T[]</code> 类型的数组，但是没有元素类型，所以有以下两种形式</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>第二个方法接收一个数组参数，如果数组足够大就使用这个数组，否则用 <code>result</code> 的元素类型构造一个足够大的新数组。</p><h3 id="_1-6-7-泛型类的静态上下文中类型变量无效" tabindex="-1"><a class="header-anchor" href="#_1-6-7-泛型类的静态上下文中类型变量无效"><span>1.6.7 泛型类的静态上下文中类型变量无效</span></a></h3><p>不能在静态字段或方法中引用类型变量，比如下面的程序：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">T</span> singleInstance<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">T</span> <span class="token function">getSingleInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Instance</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">return</span> singleInstance<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种做法是不可行的。如果可行，程序就可以声明一个 <code>Singleton&lt;Random&gt;</code> 共享一个随机数生成器，声明一个 <code>Singleton&lt;JFileChooser&gt;</code> 共享一个文件选择器对话框。类型擦除之后，只有一个 <code>Singleton</code> 类，也就是不同参数类型的类只包含一个 <code>SingleInstance</code> 字段。不同于C++的模板类可以让不同参数类型的类分别拥有不同的静态字段，因为他们本来就是不同的类；而Java的泛型类中不同参数类型的类实际上是同一个类，所以只能共享静态字段。</p><p>在这种情况下，带有类型变量的静态字段和方法是完全非法的。</p><h3 id="_1-6-8-不能抛出也不能捕获泛型类的对象" tabindex="-1"><a class="header-anchor" href="#_1-6-8-不能抛出也不能捕获泛型类的对象"><span>1.6.8 不能抛出也不能捕获泛型类的对象</span></a></h3><p>既不能抛出也不能捕获泛型类的对象，实际上，泛型类扩展 <code>Throwable</code> 都是不合法的。</p><p>例如下面的定义是不合法的：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Problem</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>catch</code> 子句中不能使用类型变量：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token keyword">class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">T</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过，在异常规范中使用类型变量是允许的，比如下面的程序是合法的：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">T</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> realCause<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        t<span class="token punctuation">.</span><span class="token function">initCause</span><span class="token punctuation">(</span>realCause<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">throw</span> t<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-6-9-可以取消对检查型异常的检查" tabindex="-1"><a class="header-anchor" href="#_1-6-9-可以取消对检查型异常的检查"><span>1.6.9 可以取消对检查型异常的检查</span></a></h3><p>Java处理异常的基本原则是，必须为所有检查型异常提供一个处理器，不过可以利用泛型取消掉这个机制，关键在于以下方法：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">throwAs</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">T</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">throw</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> t<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设这个方法包含在接口 <code>Task</code> 中，如果有一个检查型异常 <code>e</code> ，并调用</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">Task</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RuntimeException</span><span class="token punctuation">&gt;</span></span><span class="token function">throwAs</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>编译器会认为 <code>e</code> 是一个非检查型异常。</p><p>以下代码会把所有异常都转换为编译器所认为的非检查型异常：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// do work</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">Task</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RuntimeException</span><span class="token punctuation">&gt;</span></span><span class="token function">throwAs</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样可以消除Java类型系统的一个基本限制，相当于做了一个捕获任意异常。</p><h3 id="_1-6-10-注意擦除后的冲突" tabindex="-1"><a class="header-anchor" href="#_1-6-10-注意擦除后的冲突"><span>1.6.10 注意擦除后的冲突</span></a></h3><p>擦除泛型类型后，不允许创建引发冲突的条件。例如下面的程序：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> first<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> second<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果类型变量为 <code>String</code> 也就是 <code>Pair&lt;String&gt;</code> ，从概念上讲它有两个 <code>equals</code> 方法</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>但是方法 <code>equals(T)</code> 类型擦除后就是 <code>equals(Object)</code> 会和 <code>Object.equals</code> 方法产生冲突，解决的办法就是重新命名引发冲突的方法。</p><blockquote><p>泛型规范指出了另一个规则：“为了支持擦除转换，我们要施加一个限制：倘若两个接口类型是同一接口的不同参数化，一个类或类型变量就不能同时作为这两个接口类型的子类。</p></blockquote><p>根据上面的规则，下面的代码是非法的：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Manager</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果上述代码可行，类 <code>Manager</code> 就同时实现了 <code>Comparable&lt;Employee&gt;</code> 和 <code>Comparable&lt;Manager&gt;</code> 两个接口。</p><p>但是，以下非泛型版本是合法的：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>其原因很微妙，这有可能与合成的桥方法产生冲突，实现了 <code>Comparable&lt;X&gt;</code> 的类会获得一个桥方法</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">X</span><span class="token punctuation">)</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不可能对不同的类型 <code>X</code> 有两个这样的方法。</p><h2 id="_1-7-泛型类型的继承规则" tabindex="-1"><a class="header-anchor" href="#_1-7-泛型类型的继承规则"><span>1.7 泛型类型的继承规则</span></a></h2><p>一般来讲，无论类 <code>S</code> 和 <code>T</code> 有什么关系，类 <code>Pair&lt;S&gt;</code> 和 <code>Pair&lt;T&gt;</code> 之间都没有任何关系。</p><p>这种严格的限制对于类型安全非常必要。</p><p>不同于数组，超类的数组变量可以引用子类数组对象，但是将超类对象引用存储到这个数组中时会抛出 <code>ArrayStoreException</code> 异常。</p><p>总是可以将参数化类型转换为原始类型，这样做可以和遗留代码进行交互，但是转换成原始类型有可能会导致类型错误，不过这个问题并不是很严重，这里失去的只是泛型程序设计提供的附加安全性。</p><p>泛型类可以扩展或实现其他的泛型类，就这一点而言，他们与普通的类没有什么区别。</p><h2 id="_1-8-通配符类型" tabindex="-1"><a class="header-anchor" href="#_1-8-通配符类型"><span>1.8 通配符类型</span></a></h2><h3 id="_1-8-1-通配符概念" tabindex="-1"><a class="header-anchor" href="#_1-8-1-通配符概念"><span>1.8.1 通配符概念</span></a></h3><p>在通配符类型中，允许参数类型变化，例如</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>表示任何泛型 <code>Pair</code> 类型，它的类型参数是 <code>Employee</code> 的子类，例如 <code>Pair&lt;Manager&gt;</code> 。</p><p>比如下面的方法</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printBuddies</span><span class="token punctuation">(</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>不能将 <code>Pair&lt;Manager&gt;</code> 传递给这个方法，但是使用通配符类型就可以传递</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printBuddies</span><span class="token punctuation">(</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>类型 <code>Pair&lt;Manager&gt;</code> 是 <code>Pair&lt;? extends Employee&gt;</code> 的子类型。</p><p>引入有限定的通配符类型，可以区分安全的访问器方法和不安全的更改器方法，编译器会拒绝传入更改器的除了 <code>null</code> 以外的其他任何参数。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">void</span> setFirst <span class="token punctuation">(</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// only null is permitted</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-8-2-通配符的超类型限定" tabindex="-1"><a class="header-anchor" href="#_1-8-2-通配符的超类型限定"><span>1.8.2 通配符的超类型限定</span></a></h3><p>除了子类型限定外，通配符还有一个类型变量不具备的功能，就是超类型限定，使用 <code>super</code> 关键字。</p><p>与子类型限定相反，超类型限定可以为方法提供参数，但不能使用返回值，也就是说可以使用更改器方法，但不能使用访问器方法。</p><p>两种限定方式合起来就是，超类型限定允许写入泛型对象，子类型限定允许读取泛型对象。</p><p>另外，还可以将多个限定组合起来使用，例如下面的程序</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">TestClass</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">minmax</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>超类型限定的另一个常见的用法是作为一个函数式接口的参数式类型，例如 <code>Collection</code> 接口有一个方法</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">removeIf</span><span class="token punctuation">(</span><span class="token class-name">Predicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> filter<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_1-8-3-无限定通配符" tabindex="-1"><a class="header-anchor" href="#_1-8-3-无限定通配符"><span>1.8.3 无限定通配符</span></a></h3><p>无限定通配符的访问器返回值只能赋给 <code>Object</code> 变量，更改器方法只能接受空引用参数，无限定通配符类型和原始类型的本质区别在于，可以用任意 <code>Object</code> 对象调用原始类型的更改器方法。</p><p>无限定通配符类型适合某些简单的操作，比如检测是否包含空引用，当然泛型也可以实现。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">hasNulls</span><span class="token punctuation">(</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> p<span class="token punctuation">.</span>getFirst <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> p<span class="token punctuation">.</span>getSecond <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-8-4-通配符捕获" tabindex="-1"><a class="header-anchor" href="#_1-8-4-通配符捕获"><span>1.8.4 通配符捕获</span></a></h3><p>比如编写一个方法来交换对组中的元素，但是通配符不是类型变量，不能编写使用通配符作为一种类型的代码，不过可以通过编写一个泛型方法作为辅助方法，这个泛型方法中的类型参数可以捕获通配符。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">swapHelper</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">swapHelper</span><span class="token punctuation">(</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">T</span> t <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    p<span class="token punctuation">.</span><span class="token function">setFirst</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    p<span class="token punctuation">.</span><span class="token function">setSecond</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通配符在这里不是必须的，不过在某些情况下，通配符捕获是不可避免的。</p><p>需要注意的是，通配符捕获只有在非常有限的情况下才合法。</p><h2 id="_1-9-反射和泛型" tabindex="-1"><a class="header-anchor" href="#_1-9-反射和泛型"><span>1.9 反射和泛型</span></a></h2><p>尽管由于类型擦除，使用反射得不到多少关于泛型类的信息，不过还是有一些信息是可以得到的。</p><h3 id="_1-9-1-泛型class类" tabindex="-1"><a class="header-anchor" href="#_1-9-1-泛型class类"><span>1.9.1 泛型Class类</span></a></h3><p>现在 <code>Class</code> 类是泛型类，类型参数允许 <code>Class&lt;T&gt;</code> 的方法有更特定的返回类型，比如以下方法就使用了类型参数：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">T</span> <span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">T</span> <span class="token function">cast</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getEnumConstants</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">getSuperClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 <code>cast</code> 方法返回给定的对象，如果给定的对象实际上是 <code>T</code> 的一个子类型，现在会声明为类型 <code>T</code> ；否则会抛出 <code>BadCastException</code> 异常。</p><p>再有 <code>getEnumConstants</code> 方法，如果这个类不是 <code>enum</code> 类或 <code>T</code> 类型枚举值的一个数组，该方法会返回空引用。</p><h3 id="_1-9-2-使用class-t-进行参数匹配" tabindex="-1"><a class="header-anchor" href="#_1-9-2-使用class-t-进行参数匹配"><span>1.9.2 使用Class&lt;T&gt;进行参数匹配</span></a></h3><p>匹配泛型方法中 <code>Class&lt;T&gt;</code> 参数的类型变量有时会很有用。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">makePair</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">throws</span> <span class="token class-name">InstantiationException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalAccessException</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>newInstance<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里编译器可以通过 <code>Class&lt;T&gt;</code> 的类型参数推断出合适的类型。</p><h3 id="_1-9-3-虚拟机中的泛型类型信息" tabindex="-1"><a class="header-anchor" href="#_1-9-3-虚拟机中的泛型类型信息"><span>1.9.3 虚拟机中的泛型类型信息</span></a></h3><p>尽管Java通过类型擦除实现泛型，但是被擦除的类仍然保留原泛型的一些微弱记忆。比如原始 <code>Pair</code> 类知道它源于 <code>Pair&lt;T&gt;</code> 类，尽管 <code>Pair</code> 类的对象无法区分它构造为 <code>Pair&lt;String&gt;</code> 还是 <code>Pair&lt;Employee&gt;</code> 。</p><p>关于泛型中的类型限定、通配符这些相关的数据，可以通过 <code>java.lang.reflect</code> 包中的相关接口获取。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">Class</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">interface</span> <span class="token class-name">TypeVariable</span><span class="token punctuation">;</span> <span class="token comment">// e.g. T extends Employee</span></span>
<span class="line"><span class="token keyword">interface</span> <span class="token class-name">WildcardType</span><span class="token punctuation">;</span> <span class="token comment">// e.g. ? super Manager</span></span>
<span class="line"><span class="token keyword">interface</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">;</span> <span class="token comment">// e.g. Comparable&lt;? super T&gt;</span></span>
<span class="line"><span class="token keyword">interface</span> <span class="token class-name">GenericArrayType</span><span class="token punctuation">;</span> <span class="token comment">// e.g. T[]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>后面四个是接口，虚拟机会实例化实现这些接口的类。</p><h3 id="_1-9-4-类型字面量" tabindex="-1"><a class="header-anchor" href="#_1-9-4-类型字面量"><span>1.9.4 类型字面量</span></a></h3><p>在利用反射分析类的能力、利用反射在运行时分析对象等相关章节，提到过使用反射操作特定类的对象。</p><p>在泛型类中，可以使用刚才提到的四个接口，类似地处理泛型类的对象。</p><p><strong>至此，应该就可以顺畅地学习集合的相关内容了吧？怀疑</strong></p><h1 id="_2-集合" tabindex="-1"><a class="header-anchor" href="#_2-集合"><span>2 集合</span></a></h1><h2 id="_2-1-java集合框架" tabindex="-1"><a class="header-anchor" href="#_2-1-java集合框架"><span>2.1 Java集合框架</span></a></h2><p>Java的集合类库的规模比较小，易于学习，没有C++的STL那么复杂。</p><h3 id="_2-1-1-集合接口与实现分离" tabindex="-1"><a class="header-anchor" href="#_2-1-1-集合接口与实现分离"><span>2.1.1 集合接口与实现分离</span></a></h3><p>Java的集合类库将接口与实现分离，这一点和其他数据结构类库的常见做法相同。</p><p>例如考虑一个队列的数据结构，队列有两种实现方式，一种是链表，另一种是循环数组。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CircularArrayQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedListQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每种不同的具体实现可以用一个实现了 <code>Queue</code> 接口的类表示。</p><p>使用时，构造集合之后不需要知道具体使用了哪种实现，因此只有在构造集合对象时才会使用具体的类。可以使用接口类型变量引用集合对象。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CircularArrayQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedListQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>需要更换实现时，只需要修改构造语句一处就可以了，这样会很方便。</p><p>另外，Java的API中有一组以 <code>Abstract</code> 开头的类，这些类是为类库实现者准备的，如果想要提供自己的实现，扩展这些类比实现接口要容易一些。</p><h3 id="_2-1-2-collection接口" tabindex="-1"><a class="header-anchor" href="#_2-1-2-collection接口"><span>2.1.2 Collection接口</span></a></h3><p>在Java集合类库中，集合类的基本接口是 <code>Collection</code> 接口，这个接口有两个基本方法：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>add</code> 方法用于添加元素，如果添加成功返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><code>iterator</code> 方法返回一个该集合的迭代器对象。</p><h3 id="_2-1-3-迭代器" tabindex="-1"><a class="header-anchor" href="#_2-1-3-迭代器"><span>2.1.3 迭代器</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">forEachRemaining</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> action<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过调用 <code>next</code> 方法可以让迭代器向后移动一个元素，并返回经过的元素的引用；在调用 <code>next</code> 方法之前需要调用 <code>hasNext</code> 方法确定是否到达末尾。对于任何实现了迭代器 <code>Iterable</code> 接口的集合，都可以使用范围 <code>for</code> 循环实现遍历。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以不写循环，而是向 <code>forEachRemaining</code> 方法传入一个lambda表达式，这将对每一个元素调用这个lambda表达式。</p><p>接口中的 <code>remove</code> 方法会删除上次调用 <code>next</code> 方法经过的元素，如果没有调用过 <code>next</code> 方法，会抛出 <code>IllegalStateException</code> 异常。</p><p>和其他类库中的迭代器不同，比如C++的迭代器相当于指向指定位置元素的指针，无论是否访问该元素，都可以移动这个迭代器；而Java的迭代器可以看作处于两个元素之间，查找与移动紧密结合，可以将整个集合看作一个输入流，而 <code>Iterator.next</code> 相当于 <code>InputStream.read</code> 方法。</p><h3 id="_2-1-4-泛型实用方法" tabindex="-1"><a class="header-anchor" href="#_2-1-4-泛型实用方法"><span>2.1.4 泛型实用方法</span></a></h3><p>集合接口包含了很多实用的方法，下面是其中的一部分：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">boolean</span> <span class="token function">containsAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> from<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">boolean</span> <span class="token function">removeAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">boolean</span> <span class="token function">retainAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了该接口，Java类库提供了 <code>AbstractCollection</code> 类，其中保持 <code>size()</code> 和 <code>iterator()</code> 仍为抽象方法，其他方法均提供默认实现，方便构造集合实现。当然，也可以提供自己的实现覆盖默认方法。</p><p>除了上面的方法，还有一个很有用的方法</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">removeIf</span><span class="token punctuation">(</span><span class="token class-name">Predicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> filter<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>用于删除满足某个条件的元素。</p><h2 id="_2-2-集合框架中的接口" tabindex="-1"><a class="header-anchor" href="#_2-2-集合框架中的接口"><span>2.2 集合框架中的接口</span></a></h2><p>集合有两个基本接口，分别是 <code>Collection</code> 和 <code>Map</code> 。</p><p><img src="https://t.tutu.to/img/qaQT5" alt="image-20230818172519033"></p><p>其中 <code>List</code> 是一个有序集合，可以使用迭代器访问或随机访问。该接口定义了多个用于随机访问的方法：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">E</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ListIterator</code> 接口是 <code>Iterator</code> 的子接口，它可以向两个方向遍历，并且可以向迭代器位置之前添加元素。</p><p>由数组实现的有序集合可以支持快速随机访问，链表实现的有序集合不支持高效随机访问，最好使用迭代器访问。所以在Java 1.4版本引入了标记接口 <code>RandomAccess</code> ，这个接口不包含任何方法，但可以用来测试某个特定集合是否支持高效随机访问。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token keyword">instanceof</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// use random access algorithm</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// use sequential access algorithm</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Set</code> 接口等同于 <code>Collection</code> 接口，它是数学上的集合，需要满足元素的无序性和互异性，还要保证包含相同元素的两个集合的哈希值相同。</p><p><code>SortedMap</code> 和 <code>SortedSet</code> 接口会提供用于排序的比较器对象，定义了可以得到集合子集视图的方法。</p><p>另外Java 6引入的 <code>NavigableSet</code> 和 <code>NavigableMap</code> 包含额外的一些用于搜索和遍历有序集合映射的方法，<code>TreeSet</code> 和 <code>TreeMap</code> 实现了这些接口。</p><h2 id="_2-3-具体集合" tabindex="-1"><a class="header-anchor" href="#_2-3-具体集合"><span>2.3 具体集合</span></a></h2><p><img src="https://t.tutu.to/img/qaimB" alt="image-20230818180516589"></p><p>上面就是Java集合库中所有的集合了，集合相关的库位于 <code>java.util.*</code> 包中。</p><h3 id="_2-3-1-链表" tabindex="-1"><a class="header-anchor" href="#_2-3-1-链表"><span>2.3.1 链表</span></a></h3><p>链表的特性和相关操作在数据结构课程中已经学习过了，这里就不再赘述。至于可以调用的方法，需要的时候参阅API文档即可。</p><p>如果某个迭代器修改集合时，另一个迭代器却在遍历集合，可能就会出现混乱。假设一个迭代器指向某个元素前面的位置，而另一个迭代器刚刚删除了这个元素，现在前一个元素就是无效的，不能再使用。链表迭代器设计为可以检测到这种修改。如果一个迭代器发现它的集合被另一个迭代器修改了，或是该集合自身的某个方法修改了，就会抛出一个 <code>ConcurrentModificationException</code> 异常。</p><p>为了避免发生并发修改异常，需要遵守一个简单的规则：根据需要为一个集合关联多个只读迭代器，或者一个可读写迭代器。</p><p>检测并发修改的方法很简单，集合会跟踪更改操作的次数，每个迭代器都会为它负责的更改操作维护一个单独的更改操作数，如果迭代器检测到它自己的更改操作数和集合的总更改操作数不相等，就会抛出异常。注意，链表只跟踪对链表的结构性修改，单纯改变某个节点的值不属于结构性修改。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// java.util.List&lt;E&gt;</span></span>
<span class="line"><span class="token class-name">ListIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">ListIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> elements<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token class-name">Object</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token class-name">Object</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.util.ListIterator&lt;E&gt;</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> newElement<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">E</span> newElement<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">boolean</span> <span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">previous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">previousIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.util.LinkedList&lt;E&gt;</span></span>
<span class="line"><span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> elements<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">addLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-3-2-数组列表" tabindex="-1"><a class="header-anchor" href="#_2-3-2-数组列表"><span>2.3.2 数组列表</span></a></h3><p>数组列表 <code>ArrayList</code> 的基本操作和 <code>LinkedList</code> 类似，但是可以提供高效的随机访问操作。</p><p>类似的是 <code>Vector</code> 类，它提供了安全的多线程访问操作，但是如果只从单线程访问，会浪费大量的时间在同步操作上，所以最好使用 <code>ArrayList</code> 而不是 <code>Vector</code> 类。</p><h3 id="_2-3-3-散列集" tabindex="-1"><a class="header-anchor" href="#_2-3-3-散列集"><span>2.3.3 散列集</span></a></h3><p>Java标准库的哈希表采用分离连接散列法构造，当桶中元素过多时会将链表转为平衡二叉树以提高性能。</p><p>哈希表的键要尽可能属于一个实现了 <code>Comparable</code> 接口的类，以保证在哈希冲突严重时能将链表转为平衡二叉树。</p><p>可以设置初始桶的数量，一般而言设置为预计元素数量的$75%$到$150%$之间，标准库使用的桶的数量为$2$的幂，默认为$16$，为桶提供的任何值都会自动转换为$2$的下一个幂次。注意，Java的标准库哈希表并没有使用质数作为桶的数量。</p><p>当负载因子达到设定值后，哈希表会自动进行再散列。</p><p>哈希表的哈希值要保证和 <code>equals</code> 方法兼容，相等的元素的哈希值必须要保证相同。</p><p>哈希表中最简单的是 <code>HashSet</code> 类，它基于哈希表实现了一个集。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// java.util.HashSet&lt;E&gt;</span></span>
<span class="line"><span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> elements<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.lang.Object</span></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-3-4-树集" tabindex="-1"><a class="header-anchor" href="#_2-3-4-树集"><span>2.3.4 树集</span></a></h3><p><code>TreeSet</code> 类底层使用红黑树实现，使用树集需要实现 <code>Comparable</code> 接口，或提供 <code>Comparator</code> 比较器。</p><p>只有当需要使数据有序时，才选用树集。并且，树的排序顺序必须是全序。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// java.util.TreeSet&lt;E&gt;</span></span>
<span class="line"><span class="token class-name">TreeSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">TreeSet</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">TreeSet</span><span class="token punctuation">(</span><span class="token class-name">SortedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> s<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.util.SortedSet&lt;E&gt;</span></span>
<span class="line"><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">comprator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">last</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.util.Navigable&lt;E&gt;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">higher</span><span class="token punctuation">(</span><span class="token class-name">E</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">lower</span><span class="token punctuation">(</span><span class="token class-name">E</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">ceiling</span><span class="token punctuation">(</span><span class="token class-name">E</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token class-name">E</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">descendingIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-3-5-队列与双端队列" tabindex="-1"><a class="header-anchor" href="#_2-3-5-队列与双端队列"><span>2.3.5 队列与双端队列</span></a></h3><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 类实现了这两个接口，都可以提供双端队列，其大小可以根据需要进行扩展。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// java.util.Queue&lt;E&gt;</span></span>
<span class="line"><span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.util.Deque&lt;E&gt;</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">addLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">boolean</span> <span class="token function">offerFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">boolean</span> <span class="token function">offerLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.util.ArrayDeque&lt;E&gt;</span></span>
<span class="line"><span class="token class-name">ArrayDeque</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">ArrayDeque</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-3-6-优先队列" tabindex="-1"><a class="header-anchor" href="#_2-3-6-优先队列"><span>2.3.6 优先队列</span></a></h3><p>优先队列使用堆实现，并且库中的优先队列是一个小顶堆。</p><p>优先队列同样需要实现 <code>Comparable</code> 接口或提供 <code>Comparator</code> 比较器。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// java.util.PriorityQueue&lt;E&gt;</span></span>
<span class="line"><span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-4-映射" tabindex="-1"><a class="header-anchor" href="#_2-4-映射"><span>2.4 映射</span></a></h2><p>映射(map)用于存放键值对，通过键查找值。</p><h3 id="_2-4-1-基本映射操作" tabindex="-1"><a class="header-anchor" href="#_2-4-1-基本映射操作"><span>2.4.1 基本映射操作</span></a></h3><p>Java类库提供了 <code>HashMap</code> 和 <code>TreeMap</code> 两种实现，相关比较或排序只对键进行处理。</p><p>向映射中添加对象时，必须提供键；要获取对象，也必须使用键。</p><p>如果获取时没有与键对应的信息，将返回空引用；或者返回默认值。</p><p>键是唯一的，不能对同一个键存放两个值。</p><p>迭代处理键值对最好使用 <code>forEach</code> 方法。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// java.util.Map&lt;K, V&gt;</span></span>
<span class="line"><span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">default</span> <span class="token class-name">V</span> <span class="token function">getOrDefault</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> defaultValue<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">putAll</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> entries<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">boolean</span> <span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">boolean</span> <span class="token function">containsValue</span><span class="token punctuation">(</span><span class="token class-name">Object</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">BiConsumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> action<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.util.HashMap&lt;K, V&gt;</span></span>
<span class="line"><span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.util.TreeMap&lt;K, V&gt;</span></span>
<span class="line"><span class="token class-name">TreeMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">TreeMap</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">TreeMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> entries<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">TreeMap</span><span class="token punctuation">(</span><span class="token class-name">SortedMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> entries<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.util.SortedMap&lt;K, V&gt;</span></span>
<span class="line"><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> <span class="token function">comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">K</span> <span class="token function">firstKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">K</span> <span class="token function">lastKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-4-2-更新映射条目" tabindex="-1"><a class="header-anchor" href="#_2-4-2-更新映射条目"><span>2.4.2 更新映射条目</span></a></h3><p>正常情况下，可以得到一个与键关联的旧值，更新这个值并放回新的值。但是，如果这个键第一次出现，就需要另外处理。</p><p>有三种补救方式：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">var</span> counts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// solution 1</span></span>
<span class="line">counts<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> counts<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// solution 2</span></span>
<span class="line">counts<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">counts<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> counts<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// solution 3</span></span>
<span class="line">counts<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">sum</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一些更新条目的方法：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// java.util.Map&lt;K, V&gt;</span></span>
<span class="line"><span class="token keyword">default</span> <span class="token class-name">V</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">BiFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> remappingFunction<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">default</span> <span class="token class-name">V</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">BiFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> remappingFunction<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">default</span> <span class="token class-name">V</span> <span class="token function">computeIfPresent</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">BiFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> remappingFunction<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">default</span> <span class="token class-name">V</span> <span class="token function">computeIfAbsent</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> mappingFunction<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token class-name">BiFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> function<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">default</span> <span class="token class-name">V</span> <span class="token function">putIfAbsent</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-4-3-映射视图" tabindex="-1"><a class="header-anchor" href="#_2-4-3-映射视图"><span>2.4.3 映射视图</span></a></h3><p>集合框架不认为映射本身是一个集合。不过，可以得到映射的视图，它是一个实现了 <code>Collection</code> 接口或某个子接口的对象。</p><p>视图有三种，分别是键集、值集合与键值对集，其中值集合不是一个集。</p><p><code>KeySet</code> 不是 <code>HashSet</code> 或 <code>TreeSet</code> ，而是实现了 <code>Set</code> 接口的另外某个类的对象。<code>Set</code> 接口扩展了 <code>Collection</code> 接口。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// java.util.Map&lt;K, V&gt;</span></span>
<span class="line"><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> <span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.util.Map.Entry&lt;K, V&gt;</span></span>
<span class="line"><span class="token class-name">K</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">V</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">V</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">copyOf</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果在键集视图上调用迭代器的 <code>remove</code> 方法，实际上会从映射中删除这个键值对；但是，不能向键集视图中添加元素。同样的，键值对集也不能添加元素。</p><h3 id="_2-4-4-弱散列映射" tabindex="-1"><a class="header-anchor" href="#_2-4-4-弱散列映射"><span>2.4.4 弱散列映射</span></a></h3><p>如果对某个键的最后一个引用已经消失，那么就再也没有任何途径可以引用这个值对象了；但是由于程序中的任何部分都不再拥有这个键，因此无法从映射中删除这个键值对。这种情况下，垃圾回收器也无法删除无用的对象，因为垃圾回收器会跟踪活动的对象，只要这个映射整体是活动的，那么其中的所有桶就是活动的，它们就不能被回收。所以这种情况下，需要手动管理内存。</p><p>或者可以使用 <code>WeakHashMap</code> ，当键的唯一引用来自于哈希表条目时，这个数据结构将与垃圾回收器合作删除键值对。</p><p><code>WeakHashMap</code> 使用弱引用保存键，<code>WeakReference</code> 对象将包含另一个对象的引用，这里引用的是键。正常情况下，如果垃圾回收器发现某个对象已经没有引用了，就会将其回收。如果这个对象只能由一个 <code>WeakReference</code> 引用，垃圾回收器会将引用这个对象的弱引用放进一个队列， <code>WeakReference</code> 会定期检查这个队列，查找新的弱引用，然后删除相关联的映射条目。</p><h3 id="_2-4-5-链接散列集与映射" tabindex="-1"><a class="header-anchor" href="#_2-4-5-链接散列集与映射"><span>2.4.5 链接散列集与映射</span></a></h3><p><code>LinkedHashSet</code> 和 <code>LinkedHashMap</code> 会记住插入元素的顺序，并将元素加入到一个双向链表中。也就是说，每一个节点都有两种索引方式，一种是通过双向链表，另一种是通过哈希表。</p><p>链接散列映射可以使用访问顺序而不是插入顺序来迭代处理映射条目，每次调用 <code>get</code> 或 <code>put</code> 时，受到影响的节点将从链表的当前位置删除，并放在链表的末尾，但该节点在散列表的位置不会受到影响。</p><p>访问顺序对于实现缓存的最近最少使用原则非常重要，如果在映射表中没有找到某个元素，并且当时映射表已经很满，则可以得到它的一个迭代器，并删除它枚举的前几个元素，它们是最近最少使用的几个元素。这一过程可以自动完成，构造 <code>LinkedHashMap</code> 的一个子类并覆盖以下方法</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// an example</span></span>
<span class="line"><span class="token keyword">var</span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">0.75F</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">100</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每当这个方法返回 <code>true</code> 时，添加一个新映射条目就会导致删除 <code>eldest</code> 映射条目。</p><p>或者还可以考虑 <code>eldest</code> 映射条目来决定是否将它删除，比如检查随这个映射条目存储的时间戳。</p><h3 id="_2-4-6-枚举集与映射" tabindex="-1"><a class="header-anchor" href="#_2-4-6-枚举集与映射"><span>2.4.6 枚举集与映射</span></a></h3><p><code>Enum</code> 是一个高效的集实现，其元素属于一个枚举类型。因为枚举类型只有有限个实例，所以 <code>EnumSet</code> 在内部实现为一个位序列，如果对应的值在集中出现，则相应的位置为 <code>1</code> 。它没有构造器，需要使用静态工厂方法构造这个集。可以使用 <code>Set</code> 接口常用的方法修改 <code>EnumSet</code> 。</p><p><code>EnumMap</code> 是一个映射，它的键属于枚举类型。 <code>EnumMap</code> 可以简单高效地实现为一个值数组，需要在构造器中指定键类型。</p><blockquote><p><code>E extends Enum&lt;E&gt;</code> 意为 <code>E</code> 是一个枚举类型，因为所有枚举类型都扩展了泛型 <code>Enum</code> 类。</p></blockquote><h3 id="_2-4-7-标识散列映射" tabindex="-1"><a class="header-anchor" href="#_2-4-7-标识散列映射"><span>2.4.7 标识散列映射</span></a></h3><p><code>IdentityHashMap</code> 有一个很特殊的用途。在这里，键的哈希值不是根据 <code>hashCode</code> 计算的，而是用 <code>System.identityHashCode</code> 计算的，比如 <code>Object.hashCode</code> 根据对象地址计算哈希值就使用了这个方法，并且当两个元素进行比较时，使用的是 <code>==</code> 而不是 <code>equals</code> 方法。也就是说，不同的键对象即使内容相同，也被视为不同的对象，在实现对象遍历算法时，如果想跟踪哪些对象已经遍历过，这个类就很有用。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// java.util.WeakHashMap&lt;K, V&gt;</span></span>
<span class="line"><span class="token class-name">WeakHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">WeakHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">WeakHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.util.LinkedHashSet&lt;E&gt;</span></span>
<span class="line"><span class="token class-name">LinkedHashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">LinkedHashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">LinkedHashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.util.LinkedHashMap&lt;K, V&gt;</span></span>
<span class="line"><span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.util.EnumSet&lt;E extends Enum&lt;E&gt;&gt;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">allOf</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> enumType<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">noneOf</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> enumType<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">range</span><span class="token punctuation">(</span><span class="token class-name">E</span> from<span class="token punctuation">,</span> <span class="token class-name">E</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">of</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">,</span> <span class="token class-name">E</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> rest<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">copyOf</span><span class="token punctuation">(</span><span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> s<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">EnumSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">copyOf</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.util.EnumMap&lt;K extends Enum&lt;K&gt;, V&gt;</span></span>
<span class="line"><span class="token class-name">EnumMap</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> keyType<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.util.IdentityHashMap&lt;K, V&gt;</span></span>
<span class="line"><span class="token class-name">IdentityHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">IdentityHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> expectedMaxSize<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.lang.System</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">identityHashCode</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-5-副本与视图" tabindex="-1"><a class="header-anchor" href="#_2-5-副本与视图"><span>2.5 副本与视图</span></a></h2><p>通过使用视图，可以得到其他实现了 <code>Collection</code> 或 <code>Map</code> 接口的对象。这个方法并没有创建新的集合，它只是返回了实现某个接口的类对象，这个类的方法可以操作原集合。这种集合称为视图。</p><h3 id="_2-5-1-小集合" tabindex="-1"><a class="header-anchor" href="#_2-5-1-小集合"><span>2.5.1 小集合</span></a></h3><p>Java 9引入了一些静态方法，可以生成给定元素的集或列表，以及给定键值对的映射。</p><p>元素、键或值不能为 <code>null</code> 并且集和映射键不能重复。</p><blockquote><p>对于这些集和映射中的迭代顺序，并没有任何保证，编写程序时，不要对元素顺序有任何假设。</p></blockquote><p><code>List</code> 和 <code>Set</code> 接口有11个 <code>of</code> 方法，分别有0到10个参数，另外还有一个参数可变的版本。</p><p>对于 <code>Map</code> 接口无法提供参数可变版本，但是提供了 <code>ofEntries</code> 方法，用于接受任意多个 <code>Map.Entry&lt;K,V&gt;</code> 对象，例如：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> scores <span class="token operator">=</span> <span class="token function">ofEntries</span><span class="token punctuation">(</span><span class="token function">entry</span><span class="token punctuation">(</span><span class="token string">&quot;Peter&quot;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">                                       <span class="token function">entry</span><span class="token punctuation">(</span><span class="token string">&quot;Paul&quot;</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">                                       <span class="token function">entry</span><span class="token punctuation">(</span><span class="token string">&quot;Mary&quot;</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>of</code> 和 <code>ofEntries</code> 方法会生成某些类的对象，这些类对于每个元素会有一个实例变量或者一个后备数组提供支持。</p><p>这些集合对象是不可修改的，如果试图修改，会得到 <code>UnsupportedOperationException</code> 异常。如果需要一个可更改的集合，可以将这个不可变的集合传入构造器。</p><h3 id="_2-5-2-不可修改的副本和视图" tabindex="-1"><a class="header-anchor" href="#_2-5-2-不可修改的副本和视图"><span>2.5.2 不可修改的副本和视图</span></a></h3><p>建立一个集合的不可修改的副本，可以使用集合类型的 <code>copyOf</code> 方法，如果修改了原集合，这个副本不受影响。</p><p>如果原集合恰好是不可修改的，而且类型正确，会直接返回原集合。</p><p><code>Collections</code> 类有一些方法可以生成集合的不可修改的视图，这些视图对现有集合增加了运行时检查，如果试图修改不可修改的集合，会直接抛出异常。如果原集合改变，视图会反映这些变化。</p><p>有8种方法可以用于获得不可修改的视图，每个方法都定义为处理一个接口。</p><p>不可修改的视图并不会让集合本身变为不可变，仍然可以调用集合的原始引用修改这个集合，并且仍然可以对集合的元素调用更改器方法。</p><p>视图只是包装了接口而不是具体的集合对象，所以只能访问接口中的方法。</p><p>在这8种方法中，有些方法生成的集合的 <code>equals</code> 和 <code>hashCode</code> 方法会调用 <code>Object</code> 类的该方法，而不是底层集合的方法；但有些方法生成的集合，仍然会调用底层集合的这两个方法。</p><h3 id="_2-5-3-子范围" tabindex="-1"><a class="header-anchor" href="#_2-5-3-子范围"><span>2.5.3 子范围</span></a></h3><p>可以为很多集合建立子范围视图，第一个索引包含在内，第二个索引不包含在内。</p><p>可以对子范围应用任何操作，这些操作会自动反映到整个列表。</p><p>对于有序集合映射，可以使用排序顺序而不是元素位置建立子范围。</p><p>有些接口允许对这些子范围有更多控制，比如可以指定是否包含边界。</p><h3 id="_2-5-4-检查型视图" tabindex="-1"><a class="header-anchor" href="#_2-5-4-检查型视图"><span>2.5.4 检查型视图</span></a></h3><p>检查型视图用于对泛型类型可能出现的问题提供调试控制，检查型视图可以探测到一些某些程序代码不会触发的异常。</p><p>但是，检查型视图受限于虚拟机可以完成的运行时检查，它并不是万能的。</p><h3 id="_2-5-5-同步视图" tabindex="-1"><a class="header-anchor" href="#_2-5-5-同步视图"><span>2.5.5 同步视图</span></a></h3><p>如果从多个线程访问集合，就必须确保集合不会被意外地破坏。</p><p>类库的设计者使用视图机制来确保常规集合是线程安全的，而没有实现线程安全的集合类。</p><h3 id="_2-5-6-关于可选操作的说明" tabindex="-1"><a class="header-anchor" href="#_2-5-6-关于可选操作的说明"><span>2.5.6 关于可选操作的说明</span></a></h3><p>在集合和迭代器接口的API文档中，许多方法描述为可选操作，这可能与接口的概念冲突，但是如果建立单独的接口，会让接口数量大幅增加，不便于实现接口。</p><p>尽管集合类库应用了可选操作的技术，但是，在自己的设计中不应当依赖可选操作。</p><h2 id="_2-6-算法" tabindex="-1"><a class="header-anchor" href="#_2-6-算法"><span>2.6 算法</span></a></h2><p>除了实现集合类，集合框架还提供了一些有用的算法。</p><h3 id="_2-6-1-为什么使用泛型算法" tabindex="-1"><a class="header-anchor" href="#_2-6-1-为什么使用泛型算法"><span>2.6.1 为什么使用泛型算法</span></a></h3><p>泛型算法可以提高代码的复用性，比如下面的 <code>max</code> 方法就可以接收任何实现了 <code>Collection</code> 接口的对象。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> iter <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">T</span> largest <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">T</span> next <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>largest<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            largest <span class="token operator">=</span> next<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">return</span> largest<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-6-2-排序与混排" tabindex="-1"><a class="header-anchor" href="#_2-6-2-排序与混排"><span>2.6.2 排序与混排</span></a></h3><p><code>Collections</code> 类的 <code>sort</code> 方法可以对实现了 <code>List</code> 接口的集合进行排序。对元素和比较器的相关要求和数组类似。</p><p>Java程序对链表的排序方式是将链表元素复制到数组中，然后对数组进行排序，最后将有序的数据复制回原链表。</p><p>集合类库使用的排序算法比快排要慢一些，但这个排序算法是稳定的。</p><p>集合不需要实现所有的可选方法，因此，所有接受集合参数的方法必须描述什么时候可以安全地将集合传递给算法。比如排序算法的要求是，列表必须是可修改的，但不一定可改变大小。</p><p><code>Collections</code> 类的 <code>shuffle</code> 方法可以随机混排列表中的元素，如果提供的列表没有实现 <code>RandomAccess</code> 接口，该方法会将元素复制到数组中，然后打乱元素的顺序，最后将打乱顺序的数据复制回原列表。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// java.util.Collections</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> elements<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shuffle</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> elements<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shuffle</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> elements<span class="token punctuation">,</span> <span class="token class-name">Random</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.util.List&lt;E&gt;</span></span>
<span class="line"><span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.util.Comparator&lt;T&gt;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">reverseOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">default</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-6-3-二分查找" tabindex="-1"><a class="header-anchor" href="#_2-6-3-二分查找"><span>2.6.3 二分查找</span></a></h3><p>二分查找适用于有序，并且支持高效随机访问的集合。这个集合要实现 <code>List</code> 接口，如果这个集合没有采用 <code>Comparable</code> 接口的 <code>compareTo</code> 方法进行排序，还需要提供比较器。</p><p>如果返回值为非负，表示匹配对象的索引；如果返回负值，则表示没有匹配的元素，并且可以利用这个返回值计算应该将被查找的元素插入到集合的哪个位置，以保持集合的有序性。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line">insertPoint <span class="token operator">=</span> <span class="token operator">-</span>returnValue <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果为二分查找算法提供了链表，它将退化为线性查找。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// java.util.Collections</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> elements<span class="token punctuation">,</span> <span class="token class-name">T</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> elements<span class="token punctuation">,</span> <span class="token class-name">T</span> key<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-6-4-简单算法" tabindex="-1"><a class="header-anchor" href="#_2-6-4-简单算法"><span>2.6.4 简单算法</span></a></h3><p>标准库中的简单算法可以让程序员更轻松地读代码，便于分析代码意图。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// java.util.Collections</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> elements<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> elements<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> elements<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> elements<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> from<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">fill</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> l<span class="token punctuation">,</span> <span class="token class-name">T</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> values<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">boolean</span> <span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> l<span class="token punctuation">,</span> <span class="token class-name">T</span> oldValue<span class="token punctuation">,</span> <span class="token class-name">T</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexOfSubList</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> l<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> s<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">lastIndexOfSubList</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> l<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> s<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> l<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">frequency</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">,</span> <span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">boolean</span> <span class="token function">disjoint</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c1<span class="token punctuation">,</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> c2<span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.util.Collection&lt;E&gt;</span></span>
<span class="line"><span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">removeIf</span><span class="token punctuation">(</span><span class="token class-name">Predicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> filter<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.util.List&lt;E&gt;</span></span>
<span class="line"><span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token class-name">UnaryOperator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> op<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-6-5-批操作" tabindex="-1"><a class="header-anchor" href="#_2-6-5-批操作"><span>2.6.5 批操作</span></a></h3><p>通过批操作可以避免使用循环逐一处理元素。</p><p>通过使用子范围视图，可以限制使用批操作的范围。</p><h3 id="_2-6-6-集合与数组的转换" tabindex="-1"><a class="header-anchor" href="#_2-6-6-集合与数组的转换"><span>2.6.6 集合与数组的转换</span></a></h3><p>如果需要将数组转换为集合，可以使用 <code>List.of</code> 包装器。</p><p>如果需要将集合转换为数组，可以使用 <code>toArray</code> 方法，但是这样得到的结果是 <code>Object</code> 数组，并且不能进行强制类型转换。所以，要想创建正确类型的数组，需要向 <code>toArray</code> 方法传入数组构造器表达式。</p><p>在JDK 11之前，需要传入有正确类型的数组。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">String</span> names<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> staff <span class="token operator">=</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> names <span class="token operator">=</span> staff<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// String names = (String[]) staff.toArray();</span></span>
<span class="line"><span class="token class-name">String</span> values <span class="token operator">=</span> staff<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">String</span> values <span class="token operator">=</span> staff<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">String</span> values <span class="token operator">=</span> staff<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>staff<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-6-7-编写自己的算法" tabindex="-1"><a class="header-anchor" href="#_2-6-7-编写自己的算法"><span>2.6.7 编写自己的算法</span></a></h3><p>如果编写自己的算法，最好使用接口，而不是具体的实现。</p><p>需要考虑：完成这项工作最通用的接口是什么？是否关心顺序？</p><p>除了参数类型，也需要考虑返回值类型的通用性，总之，如果希望算法更通用并且具有扩展性，需要仔细斟酌。</p><h2 id="_2-7-遗留的集合" tabindex="-1"><a class="header-anchor" href="#_2-7-遗留的集合"><span>2.7 遗留的集合</span></a></h2><p>在集合框架出现之前，已经存在大量的遗留的容器类，这些类现在已经集成到集合框架中。</p><h3 id="_2-7-1-hashtable类" tabindex="-1"><a class="header-anchor" href="#_2-7-1-hashtable类"><span>2.7.1 Hashtable类</span></a></h3><p>经典的 <code>Hashtable</code> 类与 <code>HashMap</code> 类的作用相同，接口也基本相同。类似于 <code>Vector</code> 类，它的方法也是同步的。如果不需要考虑与遗留代码的兼容性，应该使用 <code>HashMap</code> 类。如果需要并发访问，应该使用 <code>ConcurrentHashMap</code> 类。</p><h3 id="_2-7-2-枚举" tabindex="-1"><a class="header-anchor" href="#_2-7-2-枚举"><span>2.7.2 枚举</span></a></h3><p>遗留的集合使用 <code>Enumeration</code> 接口遍历元素序列，它有两个方法，分别是 <code>hasMoreElements</code> 和 <code>nextElement</code> ，类似于 <code>Iterator</code> 接口的 <code>hasNext</code> 和 <code>next</code> 方法。</p><p>如果发现遗留的类实现了这个接口，可以使用 <code>Collections.list</code> 将元素收集到 <code>ArrayList</code> 中；或者在Java 9中可以把一个枚举转换为一个迭代器。</p><p>如果一个遗留方法需要枚举参数，静态方法 <code>Collections.enumeration</code> 将生成一个枚举对象，它会枚举集合中的元素。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// java.util.Enumeration&lt;E&gt;</span></span>
<span class="line"><span class="token keyword">boolean</span> <span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">default</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">asIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// java.util.Collections</span></span>
<span class="line"><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Enumeration</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">enumeration</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token class-name">Enumeration</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-7-3-属性映射" tabindex="-1"><a class="header-anchor" href="#_2-7-3-属性映射"><span>2.7.3 属性映射</span></a></h3><p>属性映射是一种特殊类型的映射结构，它有三个特性：</p><ol><li>键与值都是字符串。</li><li>这个映射可以很容易地保存到文件及从文件加载。</li><li>有一个二级表存放默认值。</li></ol><p>实现属性映射的Java平台类名为 <code>Properties</code> ，属性映射对于指定程序的配置选项很有用。</p><h3 id="_2-7-4-栈" tabindex="-1"><a class="header-anchor" href="#_2-7-4-栈"><span>2.7.4 栈</span></a></h3><p>栈的各种操作其实可以通过其他集合实现，甚至直接用数组都可以，并不一定非要使用栈集合。</p><p><code>Stack</code> 类扩展自 <code>Vector</code> 类，但是 <code>Vector</code> 类并不太令人满意。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// java.util.Stack&lt;E&gt;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">E</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">E</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-7-5-位集" tabindex="-1"><a class="header-anchor" href="#_2-7-5-位集"><span>2.7.5 位集</span></a></h3><p>Java平台的 <code>BitSet</code> 类会存储一个位序列，位集将位包装在字节中，使用位集比使用 <code>Boolean</code> 对象的 <code>ArrayList</code> 高效很多。</p><blockquote><p>都比C++的 <code>vector&lt;bool&gt;</code> 强。</p></blockquote><p>使用这个类可以避免掩码和其他调整位的操作。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// java.util.BitSet</span></span>
<span class="line"><span class="token class-name">BitSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">cardinality</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">boolean</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> bit<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> bit<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token keyword">int</span> bit<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">and</span><span class="token punctuation">(</span><span class="token class-name">BitSet</span> set<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">or</span><span class="token punctuation">(</span><span class="token class-name">BitSet</span> set<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">xor</span><span class="token punctuation">(</span><span class="token class-name">BitSet</span> set<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">andNot</span><span class="token punctuation">(</span><span class="token class-name">BitSet</span> set<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">IntStream</span> <span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,385)]))}const i=n(t,[["render",c],["__file","fanxingyujihe.html.vue"]]),u=JSON.parse('{"path":"/blogs/Java/fanxingyujihe.html","title":"泛型与集合","lang":"en-US","frontmatter":{"title":"泛型与集合","categories":["Java"]},"headers":[{"level":2,"title":"1.1 为什么要使用泛型程序设计","slug":"_1-1-为什么要使用泛型程序设计","link":"#_1-1-为什么要使用泛型程序设计","children":[]},{"level":2,"title":"1.2 定义简单泛型类","slug":"_1-2-定义简单泛型类","link":"#_1-2-定义简单泛型类","children":[]},{"level":2,"title":"1.3 泛型方法","slug":"_1-3-泛型方法","link":"#_1-3-泛型方法","children":[]},{"level":2,"title":"1.4 类型变量的限定","slug":"_1-4-类型变量的限定","link":"#_1-4-类型变量的限定","children":[]},{"level":2,"title":"1.5 泛型代码和虚拟机","slug":"_1-5-泛型代码和虚拟机","link":"#_1-5-泛型代码和虚拟机","children":[{"level":3,"title":"1.5.1 类型擦除","slug":"_1-5-1-类型擦除","link":"#_1-5-1-类型擦除","children":[]},{"level":3,"title":"1.5.2 转换泛型表达式","slug":"_1-5-2-转换泛型表达式","link":"#_1-5-2-转换泛型表达式","children":[]},{"level":3,"title":"1.5.3 转换泛型方法","slug":"_1-5-3-转换泛型方法","link":"#_1-5-3-转换泛型方法","children":[]},{"level":3,"title":"1.5.4 调用遗留代码","slug":"_1-5-4-调用遗留代码","link":"#_1-5-4-调用遗留代码","children":[]}]},{"level":2,"title":"1.6 限制与局限性","slug":"_1-6-限制与局限性","link":"#_1-6-限制与局限性","children":[{"level":3,"title":"1.6.1 不能用基本类型实例化类型参数","slug":"_1-6-1-不能用基本类型实例化类型参数","link":"#_1-6-1-不能用基本类型实例化类型参数","children":[]},{"level":3,"title":"1.6.2 运行时类型查询只适用于原始类型","slug":"_1-6-2-运行时类型查询只适用于原始类型","link":"#_1-6-2-运行时类型查询只适用于原始类型","children":[]},{"level":3,"title":"1.6.3 不能创建参数化类型的数组","slug":"_1-6-3-不能创建参数化类型的数组","link":"#_1-6-3-不能创建参数化类型的数组","children":[]},{"level":3,"title":"1.6.4 Varargs警告","slug":"_1-6-4-varargs警告","link":"#_1-6-4-varargs警告","children":[]},{"level":3,"title":"1.6.5 不能实例化类型变量","slug":"_1-6-5-不能实例化类型变量","link":"#_1-6-5-不能实例化类型变量","children":[]},{"level":3,"title":"1.6.6 不能构造泛型数组","slug":"_1-6-6-不能构造泛型数组","link":"#_1-6-6-不能构造泛型数组","children":[]},{"level":3,"title":"1.6.7 泛型类的静态上下文中类型变量无效","slug":"_1-6-7-泛型类的静态上下文中类型变量无效","link":"#_1-6-7-泛型类的静态上下文中类型变量无效","children":[]},{"level":3,"title":"1.6.8 不能抛出也不能捕获泛型类的对象","slug":"_1-6-8-不能抛出也不能捕获泛型类的对象","link":"#_1-6-8-不能抛出也不能捕获泛型类的对象","children":[]},{"level":3,"title":"1.6.9 可以取消对检查型异常的检查","slug":"_1-6-9-可以取消对检查型异常的检查","link":"#_1-6-9-可以取消对检查型异常的检查","children":[]},{"level":3,"title":"1.6.10 注意擦除后的冲突","slug":"_1-6-10-注意擦除后的冲突","link":"#_1-6-10-注意擦除后的冲突","children":[]}]},{"level":2,"title":"1.7 泛型类型的继承规则","slug":"_1-7-泛型类型的继承规则","link":"#_1-7-泛型类型的继承规则","children":[]},{"level":2,"title":"1.8 通配符类型","slug":"_1-8-通配符类型","link":"#_1-8-通配符类型","children":[{"level":3,"title":"1.8.1 通配符概念","slug":"_1-8-1-通配符概念","link":"#_1-8-1-通配符概念","children":[]},{"level":3,"title":"1.8.2 通配符的超类型限定","slug":"_1-8-2-通配符的超类型限定","link":"#_1-8-2-通配符的超类型限定","children":[]},{"level":3,"title":"1.8.3 无限定通配符","slug":"_1-8-3-无限定通配符","link":"#_1-8-3-无限定通配符","children":[]},{"level":3,"title":"1.8.4 通配符捕获","slug":"_1-8-4-通配符捕获","link":"#_1-8-4-通配符捕获","children":[]}]},{"level":2,"title":"1.9 反射和泛型","slug":"_1-9-反射和泛型","link":"#_1-9-反射和泛型","children":[{"level":3,"title":"1.9.1 泛型Class类","slug":"_1-9-1-泛型class类","link":"#_1-9-1-泛型class类","children":[]},{"level":3,"title":"1.9.2 使用Class<T>进行参数匹配","slug":"_1-9-2-使用class-t-进行参数匹配","link":"#_1-9-2-使用class-t-进行参数匹配","children":[]},{"level":3,"title":"1.9.3 虚拟机中的泛型类型信息","slug":"_1-9-3-虚拟机中的泛型类型信息","link":"#_1-9-3-虚拟机中的泛型类型信息","children":[]},{"level":3,"title":"1.9.4 类型字面量","slug":"_1-9-4-类型字面量","link":"#_1-9-4-类型字面量","children":[]}]},{"level":2,"title":"2.1 Java集合框架","slug":"_2-1-java集合框架","link":"#_2-1-java集合框架","children":[{"level":3,"title":"2.1.1 集合接口与实现分离","slug":"_2-1-1-集合接口与实现分离","link":"#_2-1-1-集合接口与实现分离","children":[]},{"level":3,"title":"2.1.2 Collection接口","slug":"_2-1-2-collection接口","link":"#_2-1-2-collection接口","children":[]},{"level":3,"title":"2.1.3 迭代器","slug":"_2-1-3-迭代器","link":"#_2-1-3-迭代器","children":[]},{"level":3,"title":"2.1.4 泛型实用方法","slug":"_2-1-4-泛型实用方法","link":"#_2-1-4-泛型实用方法","children":[]}]},{"level":2,"title":"2.2 集合框架中的接口","slug":"_2-2-集合框架中的接口","link":"#_2-2-集合框架中的接口","children":[]},{"level":2,"title":"2.3 具体集合","slug":"_2-3-具体集合","link":"#_2-3-具体集合","children":[{"level":3,"title":"2.3.1 链表","slug":"_2-3-1-链表","link":"#_2-3-1-链表","children":[]},{"level":3,"title":"2.3.2 数组列表","slug":"_2-3-2-数组列表","link":"#_2-3-2-数组列表","children":[]},{"level":3,"title":"2.3.3 散列集","slug":"_2-3-3-散列集","link":"#_2-3-3-散列集","children":[]},{"level":3,"title":"2.3.4 树集","slug":"_2-3-4-树集","link":"#_2-3-4-树集","children":[]},{"level":3,"title":"2.3.5 队列与双端队列","slug":"_2-3-5-队列与双端队列","link":"#_2-3-5-队列与双端队列","children":[]},{"level":3,"title":"2.3.6 优先队列","slug":"_2-3-6-优先队列","link":"#_2-3-6-优先队列","children":[]}]},{"level":2,"title":"2.4 映射","slug":"_2-4-映射","link":"#_2-4-映射","children":[{"level":3,"title":"2.4.1 基本映射操作","slug":"_2-4-1-基本映射操作","link":"#_2-4-1-基本映射操作","children":[]},{"level":3,"title":"2.4.2 更新映射条目","slug":"_2-4-2-更新映射条目","link":"#_2-4-2-更新映射条目","children":[]},{"level":3,"title":"2.4.3 映射视图","slug":"_2-4-3-映射视图","link":"#_2-4-3-映射视图","children":[]},{"level":3,"title":"2.4.4 弱散列映射","slug":"_2-4-4-弱散列映射","link":"#_2-4-4-弱散列映射","children":[]},{"level":3,"title":"2.4.5 链接散列集与映射","slug":"_2-4-5-链接散列集与映射","link":"#_2-4-5-链接散列集与映射","children":[]},{"level":3,"title":"2.4.6 枚举集与映射","slug":"_2-4-6-枚举集与映射","link":"#_2-4-6-枚举集与映射","children":[]},{"level":3,"title":"2.4.7 标识散列映射","slug":"_2-4-7-标识散列映射","link":"#_2-4-7-标识散列映射","children":[]}]},{"level":2,"title":"2.5 副本与视图","slug":"_2-5-副本与视图","link":"#_2-5-副本与视图","children":[{"level":3,"title":"2.5.1 小集合","slug":"_2-5-1-小集合","link":"#_2-5-1-小集合","children":[]},{"level":3,"title":"2.5.2 不可修改的副本和视图","slug":"_2-5-2-不可修改的副本和视图","link":"#_2-5-2-不可修改的副本和视图","children":[]},{"level":3,"title":"2.5.3 子范围","slug":"_2-5-3-子范围","link":"#_2-5-3-子范围","children":[]},{"level":3,"title":"2.5.4 检查型视图","slug":"_2-5-4-检查型视图","link":"#_2-5-4-检查型视图","children":[]},{"level":3,"title":"2.5.5 同步视图","slug":"_2-5-5-同步视图","link":"#_2-5-5-同步视图","children":[]},{"level":3,"title":"2.5.6 关于可选操作的说明","slug":"_2-5-6-关于可选操作的说明","link":"#_2-5-6-关于可选操作的说明","children":[]}]},{"level":2,"title":"2.6 算法","slug":"_2-6-算法","link":"#_2-6-算法","children":[{"level":3,"title":"2.6.1 为什么使用泛型算法","slug":"_2-6-1-为什么使用泛型算法","link":"#_2-6-1-为什么使用泛型算法","children":[]},{"level":3,"title":"2.6.2 排序与混排","slug":"_2-6-2-排序与混排","link":"#_2-6-2-排序与混排","children":[]},{"level":3,"title":"2.6.3 二分查找","slug":"_2-6-3-二分查找","link":"#_2-6-3-二分查找","children":[]},{"level":3,"title":"2.6.4 简单算法","slug":"_2-6-4-简单算法","link":"#_2-6-4-简单算法","children":[]},{"level":3,"title":"2.6.5 批操作","slug":"_2-6-5-批操作","link":"#_2-6-5-批操作","children":[]},{"level":3,"title":"2.6.6 集合与数组的转换","slug":"_2-6-6-集合与数组的转换","link":"#_2-6-6-集合与数组的转换","children":[]},{"level":3,"title":"2.6.7 编写自己的算法","slug":"_2-6-7-编写自己的算法","link":"#_2-6-7-编写自己的算法","children":[]}]},{"level":2,"title":"2.7 遗留的集合","slug":"_2-7-遗留的集合","link":"#_2-7-遗留的集合","children":[{"level":3,"title":"2.7.1 Hashtable类","slug":"_2-7-1-hashtable类","link":"#_2-7-1-hashtable类","children":[]},{"level":3,"title":"2.7.2 枚举","slug":"_2-7-2-枚举","link":"#_2-7-2-枚举","children":[]},{"level":3,"title":"2.7.3 属性映射","slug":"_2-7-3-属性映射","link":"#_2-7-3-属性映射","children":[]},{"level":3,"title":"2.7.4 栈","slug":"_2-7-4-栈","link":"#_2-7-4-栈","children":[]},{"level":3,"title":"2.7.5 位集","slug":"_2-7-5-位集","link":"#_2-7-5-位集","children":[]}]}],"git":{"createdTime":1726994140000,"updatedTime":1726994140000,"contributors":[{"name":"gitDebuger","email":"hygchn04@gmail.com","commits":1}]},"filePathRelative":"blogs/Java/泛型与集合.md"}');export{i as comp,u as data};
