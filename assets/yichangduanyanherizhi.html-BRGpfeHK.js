import{_ as a,c as s,e,o as p}from"./app-CNYnZXky.js";const l={};function c(t,n){return p(),s("div",null,n[0]||(n[0]=[e(`<h1 id="_1-异常、断言和日志" tabindex="-1"><a class="header-anchor" href="#_1-异常、断言和日志"><span>1 异常、断言和日志</span></a></h1><h2 id="_1-1-处理错误" tabindex="-1"><a class="header-anchor" href="#_1-1-处理错误"><span>1.1 处理错误</span></a></h2><p>对于方法中的错误，传统的处理方法是返回错误码，由调用方法分析，但这种方法并不能解决所有的问题。</p><p>Java允许每个方法有一个候选的退出路径，如果这个方法不能以正常的方式完成它的任务，就会选择这个退出路径。在这种情况下，方法不会返回一个值，而是抛出一个封装了错误信息的对象。</p><p>这种情况下，这个方法会立即退出，不返回正常值。并且，程序也不会从调用这个方法的代码继续执行，而是异常处理机制开始搜索一个能够这种异常的异常处理器。</p><h3 id="_1-1-1-异常分类" tabindex="-1"><a class="header-anchor" href="#_1-1-1-异常分类"><span>1.1.1 异常分类</span></a></h3><p>异常对象都是派生于 <code>Throwable</code> 类的实例，除了内置的异常类，还可以创建自己的异常类。</p><p>所有的异常都是继承自 <code>Throwable</code> 类，下面分成 <code>Error</code> 和 <code>Exception</code> 类。其中 <code>Error</code> 类层次结构描述了Java运行时系统的内部错误和资源耗尽问题，这种类型的对象不应该被抛出。这种情况下最好是保存数据并终止程序。</p><p>上面的 <code>Exception</code> 层次结构又分成 <code>RuntimeException</code> 分支和其他异常分支。一般而言，编程错误导致的异常属于 <code>RuntimeException</code> 异常分支，I/O错误之类的问题导致的异常属于其他异常。</p><p>派生自 <code>Error</code> 类或 <code>RuntimeException</code> 类的异常称为非检查型异常，所有其他异常称为检查型异常。编译器会检查是否为所有的检查型异常提供异常处理器。</p><h3 id="_1-1-2-声明检查型异常" tabindex="-1"><a class="header-anchor" href="#_1-1-2-声明检查型异常"><span>1.1.2 声明检查型异常</span></a></h3><p>有些Java方法包含在对外提供的类中，对于这些方法，应该通过方法首部的异常规范声明这个方法可能抛出异常，使用 <code>throws</code> 子句声明。</p><p>如果一个方法有可能抛出多个检查型异常，必须在方法首部列出所有的异常，每个异常之间用逗号隔开。</p><p>不需要声明Java的内部错误，即继承自 <code>Error</code> 类的异常，也不应该抛出继承自 <code>RuntimeError</code> 类的异常。</p><p>不是所有的 <code>throwable</code> 对象都需要或应该被抛出。</p><p>除了声明异常，还可以捕获异常，程序设计者可以决定是抛出异常交给调用者捕获，还是自己捕获异常并处理。</p><blockquote><p>如果在子类中覆盖了超类中的一个方法，子类方法中声明的检查型异常不能比超类方法中声明的异常更通用，子类可以抛出更特定的异常或者不抛出异常。如果超类方法没有抛出任何异常，那么子类也不能抛出任何检查型异常。</p></blockquote><p>如果类中的一个方法声明它会抛出一个异常，这个异常是某个特定类的实例，那么这个方法抛出的异常可能属于这个类，也可能是其某个子类的对象。</p><blockquote><p>C++的 <code>throw</code> 说明符在运行时执行，而不是在编译时执行。如果抛出的异常没有声明，就会调用 <code>unexpected</code> 函数，默认情况下程序会终止。</p><p>另外在C++中，如果没有给出 <code>throw</code> 异常规范，函数可能会抛出任何异常。而在Java中，没有声明 <code>throws</code> 则不会抛出任何检查型异常。</p></blockquote><h3 id="_1-1-3-抛出异常" tabindex="-1"><a class="header-anchor" href="#_1-1-3-抛出异常"><span>1.1.3 抛出异常</span></a></h3><p>如果一个已有的异常类能够满足要求，那么应该如下操作：</p><ol><li>找到一个合适的异常类</li><li>构造这个类的一个对象</li><li>抛出这个对象</li></ol><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">String</span> <span class="token function">readData</span><span class="token punctuation">(</span><span class="token class-name">Scanner</span> in<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">EOFException</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>in<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EOFException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                <span class="token comment">// or throw new EOFException(&quot;you file is too short&quot;);</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">return</span> s<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一旦方法抛出了异常，那么这个方法就不会返回调用者，所以不需要建立默认的返回值或错误码。</p><blockquote><p>在Java中只能抛出 <code>Throwable</code> 子类的对象。而在C++中可以抛出任意类型的值。</p></blockquote><h3 id="_1-1-4-创建异常类" tabindex="-1"><a class="header-anchor" href="#_1-1-4-创建异常类"><span>1.1.4 创建异常类</span></a></h3><p>如果遇到标准类无法描述清除的问题，则可以定义一个派生自 <code>Exception</code> 类或者它的某个子类的类。这个自定义类通常包含两个构造器，一个是无参数默认构造器，另一个是包含详细描述信息的构造器。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">FileFormatException</span> <span class="token keyword">extends</span> <span class="token class-name">IOEception</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">FileFormatException</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">FileFormatException</span><span class="token punctuation">(</span><span class="token class-name">String</span> grip<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">super</span><span class="token punctuation">(</span>grip<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后就可以抛出自定义的异常类型了。</p><blockquote><p><code>Throwable</code> 类有一个 <code>getMessage</code> 方法，它会返回一个描述详细错误信息的字符串，这对于调试非常有用。</p></blockquote><h2 id="_1-2-捕获异常" tabindex="-1"><a class="header-anchor" href="#_1-2-捕获异常"><span>1.2 捕获异常</span></a></h2><h3 id="_1-2-1-捕获异常概述" tabindex="-1"><a class="header-anchor" href="#_1-2-1-捕获异常概述"><span>1.2.1 捕获异常概述</span></a></h3><p>如果发生了某个异常但没有捕获，程序会终止并在控制台上打印一个消息，其中包括这个异常的类型和栈轨迹。不过，图形用户界面会捕获这个异常并打印栈轨迹消息，然后返回用户界面处理循环。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果 <code>try</code> 语句块中的任何代码抛出了 <code>catch</code> 子句指定的一个异常类，那么程序会跳过 <code>try</code> 语句块中的其余代码，然后执行 <code>catch</code> 子句中的异常处理器代码。如果 <code>try</code> 语句块中抛出未指定的异常，那么这个方法会立即退出并希望它的调用者为这种类型的异常提供了处理器。如果 <code>try</code> 语句块中没有代码抛出异常，那么程序将跳过 <code>catch</code> 语句块。</p><p>关于异常处理，如果知道这个异常该如何处理，那么就在 <code>catch</code> 中处理它，否则将它重新抛出，交给调用者处理。如果编写了一个覆盖超类方法的方法，并且这个超类方法没有抛出异常，那么就必须捕获新定义方法的所有检查型异常。</p><h3 id="_1-2-2-捕获多个异常" tabindex="-1"><a class="header-anchor" href="#_1-2-2-捕获多个异常"><span>1.2.2 捕获多个异常</span></a></h3><p>可以同时捕获多种异常类型，并且为不同类型的异常提供单独的处理器，其中可以使用 <code>e.getMessage()</code> 获取详细错误消息，或者使用 <code>e.getClass().getName()</code> 得到异常对象的实际类型。</p><p>如果两种及以上的异常的处理机制相同，可以在同一个 <code>catch</code> 子句中包含多个异常类型，只有当捕获的异常类型彼此之间不存在子类关系时才需要这个特性。</p><p>捕获多个异常时，异常变量隐含为 <code>final</code> 变量。</p><p>捕获多个异常会让代码更高效，生成的字节码只包含对应公共 <code>catch</code> 子句的一个代码块。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception1</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception2</span> <span class="token operator">|</span> <span class="token class-name">Exception3</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-2-3-再次抛出异常与异常链" tabindex="-1"><a class="header-anchor" href="#_1-2-3-再次抛出异常与异常链"><span>1.2.3 再次抛出异常与异常链</span></a></h3><p>可以在 <code>catch</code> 子句中抛出一个异常，希望改变异常的类型时会这样做。</p><p>除了提供原始异常的消息作为新异常的文本，还可以把原始异常设置为新异常的原因。捕获异常时，可以使用 <code>e.getCause()</code> 获取原始异常。这样可以在子系统中抛出高层异常，而不会丢失原始异常的细节。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> original<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServletException</span><span class="token punctuation">(</span><span class="token string">&quot;database error&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    e<span class="token punctuation">.</span><span class="token function">initCause</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">throw</span> e<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果在一个方法中出现了检查型异常，但这个方法不允许抛出检查型异常，那么可以利用这个机制将它包装成一个运行时异常并抛出。</p><h3 id="_1-2-4-finally子句" tabindex="-1"><a class="header-anchor" href="#_1-2-4-finally子句"><span>1.2.4 finally子句</span></a></h3><p>如果在 <code>try</code> 语句中获取了一些本地资源，但是由于抛出异常，资源没有被释放就停止运行，所以需要 <code>finally</code> 子句来释放这些本地资源。不论是否捕获到异常 <code>finally</code> 子句中的代码都会运行。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">var</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 1</span></span>
<span class="line">    codes<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 2</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 3</span></span>
<span class="line">    codes<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 4</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">finally</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 5</span></span>
<span class="line">    in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token comment">// 6</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外 <code>try</code> 语句还可以没有 <code>catch</code> 子句，只有 <code>finally</code> 子句。无论 <code>try</code> 语句块中是否遇到异常 <code>finally</code> 子句都会执行。如果真的遇到异常，这个异常会被重新抛出，并且必须由另一个 <code>catch</code> 子句捕获。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">var</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">finally</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方法可以显得更清楚，并且可以捕获 <code>finally</code> 子句中出现的异常。</p><blockquote><p>注意：不要再 <code>finally</code> 子句中改变控制流，它的职责就是清理资源。</p></blockquote><h3 id="_1-2-5-try-with-resources语句" tabindex="-1"><a class="header-anchor" href="#_1-2-5-try-with-resources语句"><span>1.2.5 try-with-Resources语句</span></a></h3><p>如果 <code>try</code> 语句中调用的资源实现了 <code>AutoCloseable</code> 接口，或者实现了 <code>Closeable</code> 接口，那么可以这种语句来自动关闭资源。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Resource</span> res <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 <code>AutoCloseable</code> 接口中只有一个 <code>close</code> 方法，而 <code>Closeable</code> 接口是 <code>AutoCloseable</code> 接口的子接口，它的 <code>close</code> 方法声明为抛出 <code>IOException</code> 异常。</p><p><code>try</code> 子句退出时，会自动关闭资源，不论是正常退出还是异常退出。并且，还可以同时指定多个资源。</p><p>如果 <code>try</code> 语句块抛出异常，并且 <code>close</code> 方法也抛出异常，那么原来的异常会被重新抛出，而 <code>close</code> 方法抛出的异常会被抑制，这些异常将被自动捕获并由 <code>addSuppressed</code> 方法添加到原来的异常中。可以调用 <code>getSuppressed</code> 方法获取 <code>close</code> 方法抛出的被抑制的异常。</p><p>当然，这种语句也可以包含 <code>catch</code> 和 <code>finally</code> 语句，这些子句会在资源关闭后执行。</p><h3 id="_1-2-6-分析栈轨迹元素" tabindex="-1"><a class="header-anchor" href="#_1-2-6-分析栈轨迹元素"><span>1.2.6 分析栈轨迹元素</span></a></h3><p>栈轨迹是程序执行过程中某个特定点上所有挂起的方法调用的一个列表，当Java程序因为异常终止时就会显示栈轨迹。可以调用 <code>Throwable</code> 类的 <code>printStackTrace</code> 方法访问栈轨迹的文本描述信息。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Throwable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">var</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">t<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">String</span> description <span class="token operator">=</span> out<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一种更灵活的方法是使用 <code>StackWalker</code> 类，它会生成一个 <code>StackWalker.StackFrame</code> 实例流，其中每个实例分别描述一个栈帧。可以利用以下调用迭代处理这些栈帧：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">StackWalker</span> walker <span class="token operator">=</span> <span class="token class-name">StackWalker</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">walker<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>frame <span class="token operator">-&gt;</span> analyze frame<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果想要以懒方式处理 <code>Stream&lt;StackWalker.StackFrame&gt;</code> 可以调用：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line">walker<span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>stream <span class="token operator">-&gt;</span> process stream<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>StackWalker.StackFrame</code> 类有一些方法可以得到正在执行的代码行的文件名和行号，以及类对象和方法名。其中 <code>toString</code> 方法会生成一个格式化字符串，其中包含所有这些信息。</p><h2 id="_1-3-使用异常的技巧" tabindex="-1"><a class="header-anchor" href="#_1-3-使用异常的技巧"><span>1.3 使用异常的技巧</span></a></h2><p>使用异常需要注意以下几点：</p><ol><li>异常处理不能代替简单的测试，只在异常情况下使用异常。</li><li>不要过分地细化异常，应该将正常处理和错误处理分开，将所有任务放在一个 <code>try</code> 语句块中，然后在最后捕获所有异常。</li><li>合理利用异常层次结构。不要只抛出 <code>RuntimeException</code> 异常，只捕获 <code>Throwable</code> 异常。不要为逻辑错误抛出异常，如果可以将一种异常转换为另一种更适合的异常，那么就应该这样做。</li><li>不要压制异常。</li><li>在检测到错误时，应该抛出异常就要抛出异常。</li><li>应该传递异常就要传递异常，让更合适的方法去处理异常，而不是所有的异常都自己捕获。</li><li>使用标准方法报告 <code>null</code> 指针和越界异常，通过Java库使用的消息抛出异常。</li><li>不要向最终用户显示栈轨迹。应该将栈轨迹记入日志，以便以后获取。</li></ol><h2 id="_1-4-使用断言" tabindex="-1"><a class="header-anchor" href="#_1-4-使用断言"><span>1.4 使用断言</span></a></h2><h3 id="_1-4-1-断言的概念" tabindex="-1"><a class="header-anchor" href="#_1-4-1-断言的概念"><span>1.4.1 断言的概念</span></a></h3><p>断言机制允许在测试期间在代码中插入检查，而在生产代码中自动删除这些检查。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// one</span></span>
<span class="line"><span class="token keyword">assert</span> condition<span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// two</span></span>
<span class="line"><span class="token keyword">assert</span> condition <span class="token operator">:</span> expression<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两个语句都会计算 <code>condition</code> 如果结果为 <code>false</code> 则抛出 <code>AssertionError</code> 异常，在第二个语句中 <code>expression</code> 将传入 <code>AssertionError</code> 的构造器并转换为消息字符串。</p><h3 id="_1-4-2-启用和禁用断言" tabindex="-1"><a class="header-anchor" href="#_1-4-2-启用和禁用断言"><span>1.4.2 启用和禁用断言</span></a></h3><p>默认情况下断言是禁用的，可以在运行程序时使用 <code>-enableassertions</code> 或 <code>-ea</code> 选项启用断言。</p><div class="language-cmd line-numbers-mode" data-highlighter="prismjs" data-ext="cmd" data-title="cmd"><pre class="language-cmd"><code><span class="line">java -ea Main</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>不需要重新编译程序来启用或禁用断言，启用或禁用断言是类加载器或虚拟机的任务。</p><p>禁用断言可以通过 <code>-disableassertions</code> 或 <code>-da</code> 选项实现。</p><p>可以在特定的类或包中启用或禁用断言，并且可以对不同的类和包指定启用或禁用断言。</p><div class="language-cmd line-numbers-mode" data-highlighter="prismjs" data-ext="cmd" data-title="cmd"><pre class="language-cmd"><code><span class="line">java -ea:... -da:...</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>对于没有类加载器的系统类，需要使用 <code>-enablesystemassertions</code> 或 <code>-esa</code> 来启用断言。</p><p>也可以通过编程控制是否启用断言。</p><h3 id="_1-4-3-使用断言完成参数检查" tabindex="-1"><a class="header-anchor" href="#_1-4-3-使用断言完成参数检查"><span>1.4.3 使用断言完成参数检查</span></a></h3><p>使用断言需要注意以下几点：</p><ol><li>断言失败是致命的、不可恢复的错误。</li><li>断言检查只在开发和测试阶段打开。</li><li>不应该使用断言向程序的其他部分通知发生了可恢复性的错误，或者使用断言与用户沟通问题，它只应该用于在测试阶段确定程序内部错误的位置。</li><li>断言和抛出异常是不同的处理方式，需要遵循开发文档使用。</li></ol><h3 id="_1-4-4-使用断言提供假设文档" tabindex="-1"><a class="header-anchor" href="#_1-4-4-使用断言提供假设文档"><span>1.4.4 使用断言提供假设文档</span></a></h3><p>通常使用注释提供底层假设的文档，但在某些情况下使用断言会更合适。</p><p>程序员应该充分使用断言来进行自我检查。</p><h3 id="_1-4-5-注意事项" tabindex="-1"><a class="header-anchor" href="#_1-4-5-注意事项"><span>1.4.5 注意事项</span></a></h3><p>下面是ChatGPT给出的使用断言的建议：</p><p>断言是一种强有力的调试和验证工具，但在使用它们时需要谨慎，以避免引入不必要的复杂性和安全风险。以下是一些关于如何正确合理使用断言的建议：</p><ol><li><strong>用于检测程序员错误</strong>：主要用于检测程序员的假设和预期是否正确。断言不应用于处理外部输入数据的验证，而应用于内部逻辑的验证。</li><li><strong>避免在生产代码中使用</strong>：断言通常不应该出现在生产代码中。在生产环境中禁用断言，以提高性能和安全性。</li><li><strong>不要修改程序状态</strong>：断言语句应该是无副作用的，不应该修改程序的状态。它们只是用来检查条件，并在条件失败时抛出异常。</li><li><strong>不要依赖于断言</strong>：不要依赖于断言来处理错误。错误应该通过异常处理来处理，而不是通过断言。断言只是用来快速发现问题。</li><li><strong>保持断言简单</strong>：断言条件应该简单明了，容易理解。复杂的断言条件可能会增加代码的复杂性，难以维护。</li><li><strong>文档化断言</strong>：在代码中对断言添加适当的注释，以说明它们的目的和预期条件。这有助于其他开发人员理解和维护代码。</li><li><strong>测试时启用断言</strong>：在开发和测试阶段启用断言，以确保程序在开发期间的正确性。这可以通过在运行Java程序时使用 <code>-ea</code> 选项来实现。</li><li><strong>使用断言库</strong>：在一些情况下，使用现成的断言库可以简化断言的使用。例如，JUnit框架提供了丰富的断言方法，用于编写单元测试。</li><li><strong>持续维护和评审</strong>：断言应该定期进行评审和维护。一些断言可能在代码的演化过程中变得过时或不再适用。</li></ol><p>总之，断言是一种有用的工具，可以帮助您更早地发现和解决问题。然而，使用它们需要谨慎，以确保它们不会引入不必要的复杂性或不安全的行为。在代码评审和开发过程中讨论如何使用断言是一个好主意，以确保团队达成共识并保持代码质量。</p><h2 id="_1-5-日志" tabindex="-1"><a class="header-anchor" href="#_1-5-日志"><span>1.5 日志</span></a></h2><p>日志API具有以下优点：</p><ol><li>方便启用或禁用。</li><li>性能开销低廉。</li><li>日志记录可以重定向到不同的处理器，例如控制台或文件等。</li><li>日志记录器和处理器都可以对记录进行过滤。</li><li>日志记录可以用不同的方式格式化。</li><li>应用程序可以使用多个日志处理器。</li><li>日志系统的配置由配置文件控制。</li></ol><h3 id="_1-5-1-基本日志" tabindex="-1"><a class="header-anchor" href="#_1-5-1-基本日志"><span>1.5.1 基本日志</span></a></h3><p>对于简单的日志记录，可以使用全局日志记录器并调用其 <code>info</code> 方法。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">Logger</span><span class="token punctuation">.</span><span class="token function">getGlobal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;File-&gt;Open menu item selected&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>默认情况下会在控制台打印日志记录。</p><p>如果在适当的地方调用</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">Logger</span><span class="token punctuation">.</span><span class="token function">getGlobal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setLevel</span><span class="token punctuation">(</span><span class="token class-name">Level</span><span class="token punctuation">.</span><span class="token constant">OFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>会抑制所有日志。</p><h3 id="_1-5-2-高级日志" tabindex="-1"><a class="header-anchor" href="#_1-5-2-高级日志"><span>1.5.2 高级日志</span></a></h3><p>可以使用 <code>getLogger</code> 方法创建或获取一个日志记录器</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> myLogger <span class="token operator">=</span> <span class="token class-name">Logger</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token string">&quot;grandparent.parent.me&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>为了防止未被任何变量引用的日志记录器被垃圾回收器回收，可以使用静态变量存储日志记录器的引用。</p><p>日志记录器名具有层次关系，日志记录器的父与子会共享某些属性，如果对父记录器设置了日志级别，那么它的子记录器也会继承这个级别。通常有七个日志级别：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token constant">SEVERE</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token constant">WARNING</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token constant">INFO</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token constant">CONFIG</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token constant">FINE</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token constant">FINER</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token constant">FINEST</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>默认只记录前三个级别，可以使用 <code>logger.setLevel()</code> 方法设置级别。</p><p>还可以使用 <code>Level.ALL</code> 开启所有级别的日志，或者使用 <code>Level.OFF</code> 关闭所有级别的日志。</p><p>所有级别都有日志记录方法，还可以使用 <code>log</code> 方法并指定级别。</p><p>如果将记录级别设置为比 <code>INFO</code> 更低的级别，还需要修改日志处理器的配置。</p><p>默认的日志记录会显示包含日志调用的类和方法的名字，如果虚拟机对执行过程进行了优化，就可能得不到准确的调用信息，那么可以使用 <code>logp</code> 方法获得调用类和方法的确切位置。</p><p>除此以外还有一些用来跟踪执行流的便利方法，例如 <code>entering</code> 和 <code>exiting</code> 方法。</p><p>日志的另一个常见用途是记录那些预料之外的异常，例如 <code>throwing</code> 方法和 <code>log</code> 方法。</p><h3 id="_1-5-3-修改日志管理器配置" tabindex="-1"><a class="header-anchor" href="#_1-5-3-修改日志管理器配置"><span>1.5.3 修改日志管理器配置</span></a></h3><p>默认的配置文件位于 <code>jdk/conf/logging.properties</code> 文件中。</p><p>日志属性文件由 <code>java.util.logging.LogManager</code> 类处理。</p><h3 id="_1-5-4-本地化" tabindex="-1"><a class="header-anchor" href="#_1-5-4-本地化"><span>1.5.4 本地化</span></a></h3><p>本地化的应用程序包含资源包中的本地特定信息，资源包包括一组映射，分别对应各个本地化环境。</p><p>一个程序可以包含多个资源包，每个资源包都有一个名字。要想为资源包增加映射，需要对应每个本地化环境提供一个文件。可以将这些文件与应用程序的类文件放在一起，以便 <code>ResourceBundle</code> 类自动找到他们。</p><p>请求一个日志记录器时可以指定一个资源包，然后为日志消息指定资源包的键而不是具体的日志消息字符串。</p><p>如果想要在本地化的消息中包含一些参数，可以使用占位符 <code>{0}</code> 或 <code>{1}</code> 等，通过方法调用传递具体的值。</p><h3 id="_1-5-5-处理器" tabindex="-1"><a class="header-anchor" href="#_1-5-5-处理器"><span>1.5.5 处理器</span></a></h3><p>默认情况下日志记录器将记录发送到 <code>ConsoleHandler</code> 类，它会将记录输出到 <code>System.err</code> 流。具体的，日志记录器会将记录发送到父处理器，最终的祖先处理器 <code>&quot;&quot;</code> 有一个 <code>ConsoleHandler</code> 。</p><p>日志处理器也有日志级别，对于一个要记录的日志记录，它的日志级别必须高于日志记录器和处理器二者的阈值。默认的控制台处理器的级别为 <code>INFO</code> 级别。</p><p>除了控制台处理器，还有 <code>FileHandler</code> 和 <code>SocketHandler</code> 处理器，其中 <code>SocketHandler</code> 将记录发送到指定的主机和端口，而 <code>FileHandler</code> 将记录收集到文件中。</p><p>默认记录将发送到用户主目录的 <code>javan.log</code> 文件中，默认格式化为 <code>XML</code> 格式。</p><p>如果多个应用程序使用同一个日志文件，应该打开 <code>append</code> 标志或者在文件名模式中使用 <code>%u</code> 或者使用文件循环功能，文件循环可以和 <code>append</code> 同时使用。</p><h3 id="_1-5-6-过滤器" tabindex="-1"><a class="header-anchor" href="#_1-5-6-过滤器"><span>1.5.6 过滤器</span></a></h3><p>默认会根据日志级别进行过滤，除此之外还可以添加额外的一个可选过滤器。这个过滤器需要实现 <code>Filter</code> 接口并定义以下方法</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">boolean</span> <span class="token function">isLoggable</span><span class="token punctuation">(</span><span class="token class-name">LogRecord</span> record<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>对于应该包含在日志中的记录返回 <code>true</code> 。</p><p>通过调用 <code>setFilter</code> 方法安装过滤器。</p><h3 id="_1-5-7-格式化器" tabindex="-1"><a class="header-anchor" href="#_1-5-7-格式化器"><span>1.5.7 格式化器</span></a></h3><p>自定义格式化器需要扩展 <code>Formatter</code> 类并覆盖以下方法</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">String</span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">LogRecord</span> record<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在 <code>format</code> 方法中可能会调用以下方法对记录中的消息部分进行格式化，并返回结果字符串</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">String</span> <span class="token function">formatMessage</span><span class="token punctuation">(</span><span class="token class-name">LogRecord</span> record<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果需要在已经格式化的记录的前后加上头部或尾部，需要覆盖以下方法</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">String</span> <span class="token function">getHead</span><span class="token punctuation">(</span><span class="token class-name">Handler</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">String</span> <span class="token function">getTail</span><span class="token punctuation">(</span><span class="token class-name">Handler</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>最后调用 <code>setFormatter</code> 方法安装格式化器。</p><h3 id="_1-5-8-日志技巧" tabindex="-1"><a class="header-anchor" href="#_1-5-8-日志技巧"><span>1.5.8 日志技巧</span></a></h3><p>下面是一些常用的操作</p><ol><li>对一个简单的应用选择一个日志记录器，可以把日志记录器命名为与主应用包同名。</li><li>为有大量日志记录活动的类增加静态字段。</li><li>默认的日志配置会把级别等于或高于 <code>INFO</code> 的所有消息记录到控制台，用户可以覆盖这个配置，但更好的选择是安装一个更合适的默认日志处理器。</li><li>要记录对用户有意义的消息可以使用 <code>INFO</code> 或 <code>WARNING</code> 或 <code>SEVERE</code> 级别，要记录对程序员有用的消息可以使用 <code>FINE</code> 级别。</li><li>可以使用日志记录预料之外的异常。</li></ol><h2 id="_1-6-调试技巧" tabindex="-1"><a class="header-anchor" href="#_1-6-调试技巧"><span>1.6 调试技巧</span></a></h2><p>除了调用IDE的调试器，还有一些调试技巧：</p><ol><li>实现 <code>toString</code> 方法，用打印输出或记录日志观察程序运行情况。</li><li>为每个类放置 <code>main</code> 方法，从而单独测试每个类能否正常工作。</li><li>使用JUnit框架进行单元测试。</li><li>使用日志代理，截获方法调用并将调用记入日志。</li><li>打印输出栈轨迹。</li><li>将栈轨迹捕获到字符串中。</li><li>将程序错误记入文件中。</li><li>将未捕获的异常的栈轨迹记录到文件中。</li><li>启动Java虚拟机时使用 <code>-verbose</code> 选项观察类的加载过程。</li><li>使用 <code>-Xlint</code> 选项告诉编译器找出常见的代码问题。</li><li>Java虚拟机提供了对Java应用的监控和管理支持，允许在虚拟机中安装代理来跟踪内存消耗、线程使用、类加载等情况。JDK提供了一个名为 <code>jconsole</code> 的图形工具，可以显示有关虚拟机性能的统计结果。</li><li>Java任务控制器可以提供更专业的性能分析和诊断支持。</li></ol>`,153)]))}const o=a(l,[["render",c],["__file","yichangduanyanherizhi.html.vue"]]),d=JSON.parse('{"path":"/blogs/Java/yichangduanyanherizhi.html","title":"异常、断言和日志","lang":"en-US","frontmatter":{"title":"异常、断言和日志","categories":["Java"]},"headers":[{"level":2,"title":"1.1 处理错误","slug":"_1-1-处理错误","link":"#_1-1-处理错误","children":[{"level":3,"title":"1.1.1 异常分类","slug":"_1-1-1-异常分类","link":"#_1-1-1-异常分类","children":[]},{"level":3,"title":"1.1.2 声明检查型异常","slug":"_1-1-2-声明检查型异常","link":"#_1-1-2-声明检查型异常","children":[]},{"level":3,"title":"1.1.3 抛出异常","slug":"_1-1-3-抛出异常","link":"#_1-1-3-抛出异常","children":[]},{"level":3,"title":"1.1.4 创建异常类","slug":"_1-1-4-创建异常类","link":"#_1-1-4-创建异常类","children":[]}]},{"level":2,"title":"1.2 捕获异常","slug":"_1-2-捕获异常","link":"#_1-2-捕获异常","children":[{"level":3,"title":"1.2.1 捕获异常概述","slug":"_1-2-1-捕获异常概述","link":"#_1-2-1-捕获异常概述","children":[]},{"level":3,"title":"1.2.2 捕获多个异常","slug":"_1-2-2-捕获多个异常","link":"#_1-2-2-捕获多个异常","children":[]},{"level":3,"title":"1.2.3 再次抛出异常与异常链","slug":"_1-2-3-再次抛出异常与异常链","link":"#_1-2-3-再次抛出异常与异常链","children":[]},{"level":3,"title":"1.2.4 finally子句","slug":"_1-2-4-finally子句","link":"#_1-2-4-finally子句","children":[]},{"level":3,"title":"1.2.5 try-with-Resources语句","slug":"_1-2-5-try-with-resources语句","link":"#_1-2-5-try-with-resources语句","children":[]},{"level":3,"title":"1.2.6 分析栈轨迹元素","slug":"_1-2-6-分析栈轨迹元素","link":"#_1-2-6-分析栈轨迹元素","children":[]}]},{"level":2,"title":"1.3 使用异常的技巧","slug":"_1-3-使用异常的技巧","link":"#_1-3-使用异常的技巧","children":[]},{"level":2,"title":"1.4 使用断言","slug":"_1-4-使用断言","link":"#_1-4-使用断言","children":[{"level":3,"title":"1.4.1 断言的概念","slug":"_1-4-1-断言的概念","link":"#_1-4-1-断言的概念","children":[]},{"level":3,"title":"1.4.2 启用和禁用断言","slug":"_1-4-2-启用和禁用断言","link":"#_1-4-2-启用和禁用断言","children":[]},{"level":3,"title":"1.4.3 使用断言完成参数检查","slug":"_1-4-3-使用断言完成参数检查","link":"#_1-4-3-使用断言完成参数检查","children":[]},{"level":3,"title":"1.4.4 使用断言提供假设文档","slug":"_1-4-4-使用断言提供假设文档","link":"#_1-4-4-使用断言提供假设文档","children":[]},{"level":3,"title":"1.4.5 注意事项","slug":"_1-4-5-注意事项","link":"#_1-4-5-注意事项","children":[]}]},{"level":2,"title":"1.5 日志","slug":"_1-5-日志","link":"#_1-5-日志","children":[{"level":3,"title":"1.5.1 基本日志","slug":"_1-5-1-基本日志","link":"#_1-5-1-基本日志","children":[]},{"level":3,"title":"1.5.2 高级日志","slug":"_1-5-2-高级日志","link":"#_1-5-2-高级日志","children":[]},{"level":3,"title":"1.5.3 修改日志管理器配置","slug":"_1-5-3-修改日志管理器配置","link":"#_1-5-3-修改日志管理器配置","children":[]},{"level":3,"title":"1.5.4 本地化","slug":"_1-5-4-本地化","link":"#_1-5-4-本地化","children":[]},{"level":3,"title":"1.5.5 处理器","slug":"_1-5-5-处理器","link":"#_1-5-5-处理器","children":[]},{"level":3,"title":"1.5.6 过滤器","slug":"_1-5-6-过滤器","link":"#_1-5-6-过滤器","children":[]},{"level":3,"title":"1.5.7 格式化器","slug":"_1-5-7-格式化器","link":"#_1-5-7-格式化器","children":[]},{"level":3,"title":"1.5.8 日志技巧","slug":"_1-5-8-日志技巧","link":"#_1-5-8-日志技巧","children":[]}]},{"level":2,"title":"1.6 调试技巧","slug":"_1-6-调试技巧","link":"#_1-6-调试技巧","children":[]}],"git":{"createdTime":1726994140000,"updatedTime":1726994140000,"contributors":[{"name":"gitDebuger","email":"hygchn04@gmail.com","commits":1}]},"filePathRelative":"blogs/Java/异常断言和日志.md"}');export{o as comp,d as data};
