import{_ as n,c as s,e,o as p}from"./app-DlLt4BHG.js";const l={};function c(i,a){return p(),s("div",null,a[0]||(a[0]=[e(`<h1 id="_1-对象与类" tabindex="-1"><a class="header-anchor" href="#_1-对象与类"><span>1. 对象与类</span></a></h1><h2 id="_1-1-基本概念和要求" tabindex="-1"><a class="header-anchor" href="#_1-1-基本概念和要求"><span>1.1 基本概念和要求</span></a></h2><p>Java的对象变量类似于C++中的对象指针，Java的 <code>null</code> 引用相当于C++的 <code>nullptr</code> 空指针。C++通过复制构造器和赋值运算符完成对象的复制，在Java中必须使用 <code>clone</code> 方法获得一个对象的完整副本。</p><p>能够修改对象状态的方法为更改器方法，只能访问对象不能修改对象的方法称为访问器方法。在C++中带有 <code>const</code> 后缀的方法为访问器方法，没有声明为 <code>const</code> 的方法默认为更改器方法，在Java中这两种方法在语法上没有明显的区别。</p><p>一个源文件只能有一个公共类，并且文件名必须和公共类的名字匹配，而非公共类可以有多个。</p><p>建议将实例字段标记为 <code>private</code> 以确保类的封装性。</p><h2 id="_1-2-创建类" tabindex="-1"><a class="header-anchor" href="#_1-2-创建类"><span>1.2 创建类</span></a></h2><h3 id="_1-2-1-构造器" tabindex="-1"><a class="header-anchor" href="#_1-2-1-构造器"><span>1.2.1 构造器</span></a></h3><p>构造器与类同名，并且总是结合 <code>new</code> 操作符使用，不能对已经存在的对象调用构造器来重新设置实例字段。并且，Java中的所有对象都是在堆中构造的。</p><h3 id="_1-2-2-使用null引用" tabindex="-1"><a class="header-anchor" href="#_1-2-2-使用null引用"><span>1.2.2 使用null引用</span></a></h3><p>对空引用进行操作会产生异常，如果没有捕获异常程序就会终止。</p><p>所以，调用构造器时为了避免空引用参数带来的问题，可以有两种解决方案。第一种方案是将空参数转换为一个合适的值，第二种方案是拒绝空引用并抛出异常。下面是对应的代码实现</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token class-name">String</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        name <span class="token operator">=</span> <span class="token string">&quot;unknown&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">else</span> name <span class="token operator">=</span> n<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token class-name">String</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    name <span class="token operator">=</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNullElse</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token string">&quot;unknown&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token class-name">String</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    name <span class="token operator">=</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token string">&quot;the name cannot be null&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二种写法是第一种写法的等价表达，第三种写法会抛出 <code>NullPointerException</code> 异常。</p><h3 id="_1-2-3-隐式参数" tabindex="-1"><a class="header-anchor" href="#_1-2-3-隐式参数"><span>1.2.3 隐式参数</span></a></h3><p>在每一个方法内都有一个隐式参数 <code>this</code> 代表当前的对象，类似于C++中的 <code>this</code> 指针。</p><h3 id="_1-2-4-封装的优点" tabindex="-1"><a class="header-anchor" href="#_1-2-4-封装的优点"><span>1.2.4 封装的优点</span></a></h3><p>想要获得或修改实例字段的值，需要提供以下三项内容：</p><ol><li>私有的实例字段</li><li>公共的字段访问器方法</li><li>公共的字段更改器方法</li></ol><blockquote><p>注意：不要编写返回可变对象引用的访问器方法，这样会破坏私有字段的私有状态。如果需要返回可变对象的引用，首先应该对它进行克隆，然后返回对象的副本。</p></blockquote><h3 id="_1-2-5-基于类的访问权限" tabindex="-1"><a class="header-anchor" href="#_1-2-5-基于类的访问权限"><span>1.2.5 基于类的访问权限</span></a></h3><p>一个类的方法可以访问这个类的所有对象的私有数据，也就是说可以通过静态方法操作该类的所有对象，或者通过某个对象的方法操作其他同类对象。</p><h3 id="_1-2-6-私有方法" tabindex="-1"><a class="header-anchor" href="#_1-2-6-私有方法"><span>1.2.6 私有方法</span></a></h3><p>将方法权限 <code>public</code> 改为 <code>private</code> 即可，私有方法是辅助方法，不作为接口使用。</p><h3 id="_1-2-7-final实例字段" tabindex="-1"><a class="header-anchor" href="#_1-2-7-final实例字段"><span>1.2.7 final实例字段</span></a></h3><p>这样的字段必须在构造对象时完成初始化，并且以后不能再进行更改，并且主要应用于基本类型或不可变类型。如果修饰的变量为可变对象变量，那么只是该变量不能再指向其他对象，但是这个对象本身可以更改。</p><h2 id="_1-3-静态字段与静态方法" tabindex="-1"><a class="header-anchor" href="#_1-3-静态字段与静态方法"><span>1.3 静态字段与静态方法</span></a></h2><h3 id="_1-3-1-静态字段与静态常量" tabindex="-1"><a class="header-anchor" href="#_1-3-1-静态字段与静态常量"><span>1.3.1 静态字段与静态常量</span></a></h3><p>每个静态字段只有一个副本，可以认为静态字段属于类，也就是类字段。静态字段在加载类时初始化，静态字段分为静态变量和静态常量。虽然不建议使用公共变量，但是可以使用公共常量。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> nextID <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">Math</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">double</span> <span class="token constant">PI</span> <span class="token operator">=</span> <span class="token number">3.14159265358979323846</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意的是静态常量最好使用全大写。</p><p>有意思的是 <code>System</code> 类的 <code>out</code> 静态常量可以被 <code>setOut</code> 方法重定向到不同的流，原因在于 <code>setOut</code> 方法是一个原生方法，原生方法可以绕过Java的访问控制机制。</p><blockquote><ol><li><p>原生(Native)函数的概念</p><p>在Java程序中，可以使用由其他编程语言实现的函数，这种函数，在Java中被称之为原生(Native)函数。</p></li><li><p>在Java程序中使用原生函数的优缺点</p><ul><li><p>优点</p><ul><li><p>在Java程序中，可以复用已由其他语言实现的各种库。可能已存在很多由其他语言编写的库，为了在Java程序中能够复用这些库，就需要用到原生函数。</p></li><li><p>增加了Java标准类库中不存在的功能。由于Java的可移植性，它不能利用与操作系统相关的特点，因此，当要访问特定的硬件设备或使用新的网络驱动器时，就不得不使用原生函数提供的功能。</p></li></ul></li><li><p>缺点</p><ul><li><p>任何包含原生函数的Java类均不能用于Applet程序。这主要是出于安全性的考虑，因为Java的安全管理机制难以防范来自原生函数的恶意攻击。</p></li><li><p>使用原生函数将会使Java程序失去可移植性。因为，你必须为运行该Java程序的各种平台编写不同的原生函数链接库。</p></li></ul></li></ul></li></ol></blockquote><h3 id="_1-3-2-静态方法" tabindex="-1"><a class="header-anchor" href="#_1-3-2-静态方法"><span>1.3.2 静态方法</span></a></h3><p>静态方法即不操作对象的方法。静态方法不能访问实例字段，但是可以访问静态字段。建议使用类名调用静态方法，尽管也可以使用对象调用静态方法，但是容易造成混淆，不建议这样做。</p><h3 id="_1-3-3-工厂方法" tabindex="-1"><a class="header-anchor" href="#_1-3-3-工厂方法"><span>1.3.3 工厂方法</span></a></h3><p>静态方法的另一种常见用途就是工厂方法，可以使用静态工厂方法来构造对象。通过工厂方法可以实现更复杂的更自定义化的对象构造。</p><h3 id="_1-3-4-main方法" tabindex="-1"><a class="header-anchor" href="#_1-3-4-main方法"><span>1.3.4 main方法</span></a></h3><p>可以为每一个类设置一个 <code>main</code> 方法从而实现为该类增加演示代码。当且仅当从该类开始加载程序，才会执行该类的 <code>main</code> 方法。</p><h2 id="_1-4-方法参数" tabindex="-1"><a class="header-anchor" href="#_1-4-方法参数"><span>1.4 方法参数</span></a></h2><p>Java语言总是按值调用，方法会得到参数值的一个副本。也就是说，Java中无法使用类似 <code>swap</code> 的方法。</p><h2 id="_1-5-对象构造" tabindex="-1"><a class="header-anchor" href="#_1-5-对象构造"><span>1.5 对象构造</span></a></h2><h3 id="_1-5-1-重载" tabindex="-1"><a class="header-anchor" href="#_1-5-1-重载"><span>1.5.1 重载</span></a></h3><p>方法名和参数类型共同构成方法的签名，编译器需要挑选出合适的方法进行调用，如果不能匹配则会产生编译时错误，挑选合适方法的过程称为重载解析。需要注意的是，返回类型不是方法签名的一部分，不能有两个名字相同、参数类型也相同但返回类型不同的方法。</p><h3 id="_1-5-2-默认字段初始化" tabindex="-1"><a class="header-anchor" href="#_1-5-2-默认字段初始化"><span>1.5.2 默认字段初始化</span></a></h3><p>如果在构造器中没有显式地对字段进行初始化，那么就会将它自动设置为默认值。</p><h3 id="_1-5-3-无参数构造器" tabindex="-1"><a class="header-anchor" href="#_1-5-3-无参数构造器"><span>1.5.3 无参数构造器</span></a></h3><p>如果一个类没有构造器，那么会自动生成一个无参数构造器，将所有实例字段设置为默认值。如果类中提供了至少一个构造器，那么就不会自动产生无参数构造器，需要手动添加。</p><h3 id="_1-5-4-显式字段初始化" tabindex="-1"><a class="header-anchor" href="#_1-5-4-显式字段初始化"><span>1.5.4 显式字段初始化</span></a></h3><p>可以直接在类定义中对字段赋值，这个赋值将在调用构造器之前完成，如果所有的构造器都要将某个字段设置为同一个值，那么很适合采用这个方式。</p><p>初始值不一定是常量值，也可以在赋值时调用方法。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> nextId<span class="token punctuation">;</span></span>
<span class="line">   	<span class="token keyword">private</span> <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token function">advanceId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">advanceId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">int</span> r <span class="token operator">=</span> nextId<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">return</span> r<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-5-5-参数名" tabindex="-1"><a class="header-anchor" href="#_1-5-5-参数名"><span>1.5.5 参数名</span></a></h3><p>参数变量会遮蔽同名的实例字段，如果需要访问实例字段需要使用 <code>this</code> 参数。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">String</span> name<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">double</span> salary<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">double</span> salary<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">=</span> salary<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至于说具体的参数命名，形成自己的编程风格，使用容易理解的变量名就可以了。</p><h3 id="_1-5-6-调用另一个构造器" tabindex="-1"><a class="header-anchor" href="#_1-5-6-调用另一个构造器"><span>1.5.6 调用另一个构造器</span></a></h3><p>如果构造器的第一个语句形如 <code>this(...)</code> 那么这个构造器将调用同一个类的另一个构造器。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">String</span> name<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">double</span> salary<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">double</span> salary<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">=</span> salary<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token keyword">double</span> salary<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token string">&quot;unknown&quot;</span><span class="token punctuation">,</span> salary<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-5-7-初始化块" tabindex="-1"><a class="header-anchor" href="#_1-5-7-初始化块"><span>1.5.7 初始化块</span></a></h3><p>在类的声明中可以包含任意的代码块，构造这个类的对象时，这些代码块就会执行。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> nextId<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">double</span> salary<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// object initialization block</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        id <span class="token operator">=</span> nextId<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注意：可以在初始化块中设置字段，即使这些字段在后面才被定义。但是为了避免循环定义，不允许读取在后面初始化的字段。为了避免错误，建议将初始化块放置在字段定义之后。</p></blockquote><p>下面是调用构造器的具体步骤：</p><ol><li>如果构造器的第一行调用了另一个构造器则执行另一个构造器</li><li>否则： <ol><li>将所有实例字段初始化为默认值</li><li>按照在类声明中出现的顺序，执行所有字段初始化方法和初始化块</li></ol></li><li>执行字段构造器主体代码</li></ol><p>可以通过提供初始值或使用静态初始化块来初始化静态字段，在类第一次加载时会完成静态字段的初始化，如果不显式地指定静态字段的值，则静态字段会自动设置为默认值。所有的静态字段初始化方法以及静态初始化块都将按照类声明中出现的顺序执行。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> nextId<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Random</span> generator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">static</span> <span class="token punctuation">{</span></span>
<span class="line">        nextId <span class="token operator">=</span> generator<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-5-8-对象析构" tabindex="-1"><a class="header-anchor" href="#_1-5-8-对象析构"><span>1.5.8 对象析构</span></a></h3><p>由于Java会自动完成垃圾回收，所以Java不支持析构器语法。</p><p>如果某些对象使用了内存以外的系统资源，那么就需要进行资源回收。如果资源在使用完之后需要立即关闭，那么应当提供 <code>close</code> 方法来完成必要的清理工作，可以在对象使用完时调用这个 <code>close</code> 方法。如果可以等到虚拟机退出，那么可以用方法 <code>Runtime.addShutdownHook</code> 增加一个关闭钩。在Java 9中可以使用 <code>Cleaner</code> 类注册一个动作，当对象不再可达时就会完成这个动作。</p><p>注意不要使用 <code>finalize</code> 方法完成清理，该方法已经被废弃。</p><h2 id="_1-6-记录" tabindex="-1"><a class="header-anchor" href="#_1-6-记录"><span>1.6 记录</span></a></h2><p>记录的最终版本在 JDK 16 中发布。</p><h3 id="_1-6-1-概念" tabindex="-1"><a class="header-anchor" href="#_1-6-1-概念"><span>1.6.1 概念</span></a></h3><p>记录是一种特殊形式的类，其状态不可变，并且公共可读。</p><p>例如下面的记录</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">record</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>它等价于下面的类</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">double</span> x<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">double</span> y<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>记录的实例字段称为组件，访问器的方法名和实例字段同名。除了字段访问器方法，每个记录有三个自动定义的方法，分别是 <code>toString</code> <code>equals</code> 和 <code>hashCode</code> 。</p><p>对于这些自动提供的方法，也可以定义自己的版本，只要它们有相同的参数和返回类型。</p><p>也可以为记录增加其他方法，记录也可以有静态字段和方法，但是不能给记录增加实例字段。</p><p>尽管实例字段自动为 <code>final</code> 字段，但是他们可能是可变对象的引用。</p><h3 id="_1-6-2-构造器-标准、自定义和简洁" tabindex="-1"><a class="header-anchor" href="#_1-6-2-构造器-标准、自定义和简洁"><span>1.6.2 构造器：标准、自定义和简洁</span></a></h3><p>自动定义的设置所有实例字段的构造器称为标准构造器。</p><p>自定义构造器的第一个语句必须调用另一个构造器，最终会调用到标准构造器。</p><p>如果标准构造器需要完成额外的工作，那么可以提供自己的实现；实现标准构造器时可以使用简洁形式，不需要指定参数列表。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">record</span> <span class="token class-name">Range</span><span class="token punctuation">(</span><span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Range</span><span class="token punctuation">(</span><span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>from <span class="token operator">&lt;=</span> <span class="token keyword">to</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">this</span><span class="token punctuation">.</span>from <span class="token operator">=</span> from<span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">to</span> <span class="token operator">=</span> <span class="token keyword">to</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">this</span><span class="token punctuation">.</span>from <span class="token operator">=</span> <span class="token keyword">to</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">to</span> <span class="token operator">=</span> from<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token comment">// or compact</span></span>
<span class="line"><span class="token keyword">record</span> <span class="token class-name">Range</span><span class="token punctuation">(</span><span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Range</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>from <span class="token operator">&gt;</span> <span class="token keyword">to</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">int</span> temp <span class="token operator">=</span> from<span class="token punctuation">;</span></span>
<span class="line">            from <span class="token operator">=</span> <span class="token keyword">to</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">to</span> <span class="token operator">=</span> from<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简洁形式的主体是标准构造器的前奏，不能在简洁构造器的主体中读取或修改实例字段。</p><h2 id="_1-7-包" tabindex="-1"><a class="header-anchor" href="#_1-7-包"><span>1.7 包</span></a></h2><p>Java允许使用包(package)将类组织在一个集合中，借助包可以方便地组织代码，并将自己的代码与其他人的代码库分开。</p><h3 id="_1-7-1-包名" tabindex="-1"><a class="header-anchor" href="#_1-7-1-包名"><span>1.7.1 包名</span></a></h3><p>使用包的主要原因是确保类的唯一性。为了确保包名的绝对唯一性，可以使用域名的逆序作为包名，然后对于不同的项目使用不同的子包，再然后可以追加一个项目名，最后把类放在这个包里，那么就得到了这个类的完全限定名。</p><p>例如 <code>com.horstmann.corejava.Employee</code> 。</p><p>从编译器的角度看，嵌套的包之间没有任何关系，每一个包都是独立的类集合。例如 <code>java.util</code> 和 <code>java.util.jar</code> 包毫无关系。</p><h3 id="_1-7-2-类的导入" tabindex="-1"><a class="header-anchor" href="#_1-7-2-类的导入"><span>1.7.2 类的导入</span></a></h3><p>一个类可以使用所在包中的所有类以及其他包中的公共类。</p><p>访问另一个包中的公共类有两种方法，第一种方法是使用完全限定名，例如</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span></span>LocalDate</span> today <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span></span>LocalDate</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>另一种方法是使用 <code>import</code> 语句，可以使用该语句导入整个包或者某个特定的类，该语句应该位于 <code>package</code> 语句的后面，其他代码的前面。使用通配符 <code>*</code> 导入整个包时只能导入一个包，而不能导入所有包。在发生命名冲突时，需要显式指定使用的是哪个包中的类。</p><blockquote><p>在包中定位类是编译器的工作，类文件中的字节码总是使用完整的包名来引用其他类。</p></blockquote><h3 id="_1-7-3-静态导入" tabindex="-1"><a class="header-anchor" href="#_1-7-3-静态导入"><span>1.7.3 静态导入</span></a></h3><p>可以通过 <code>import</code> 语句导入静态方法和静态字段，例如</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token operator">*</span></span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这样使用静态字段和静态方法就不再需要指定类名。</p><h3 id="_1-7-4-在包中增加类" tabindex="-1"><a class="header-anchor" href="#_1-7-4-在包中增加类"><span>1.7.4 在包中增加类</span></a></h3><p>将类放入包中需要将包名放置在源文件的开头，例如</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>horstmann<span class="token punctuation">.</span>corejava</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果没有在源文件中放置 <code>package</code> 语句，那么这个源文件中的类就属于无名包，无名包没有包名。</p><p>将源文件放到与完整包名匹配的子目录中，例如前面的包中所有的源文件都应该放在子目录 <code>com/horstmann/corejava</code> 中，编译器将类文件也放在相同的目录结构中。编译和运行类需要从基目录开始。</p><p>编译器处理源文件，而解释器加载类。</p><blockquote><p>注意：编译器在编译源文件时不检查目录结构，不符合目录结构的源文件也可以通过编译，但是最终的程序无法运行。如果包与目录不匹配，虚拟机就无法加载这些类。</p></blockquote><h3 id="_1-7-5-包访问" tabindex="-1"><a class="header-anchor" href="#_1-7-5-包访问"><span>1.7.5 包访问</span></a></h3><p>标记为 <code>public</code> 的部分可以由任意类访问，标记为 <code>private</code> 的部分只能由定义其的类使用，无标记的部分可以由同一个包中所有方法访问。变量必须显式地标记为 <code>private</code> 否则将默认为包可访问，会破坏类的封装性。</p><p>在默认情况下，包不是封闭的实体，任何人都可以向包中添加更多的类，可以利用包访问编写恶意代码。</p><p>目前，JDK禁止加载包名以 <code>java.</code> 开头的用户自定义类；另一种保护机制是让JAR文件声明包为密封的，以防止第三方修改，该方法已经过时；现在应该使用模块封装包。</p><h3 id="_1-7-6-类路径" tabindex="-1"><a class="header-anchor" href="#_1-7-6-类路径"><span>1.7.6 类路径</span></a></h3><p>类的路径必须与包名相匹配。另外，类文件也可以存储在JAR文件中，在一个JAR文件中可以包含多个压缩格式的类文件和子目录。JAR文件使用ZIP格式组织文件和子目录，可以使用任何ZIP工具查看JAR文件。</p><p>为了使类能够被多个程序共享，需要做到以下几点：</p><ol><li>将类文件放到一个目录中</li><li>将JAR文件放到一个目录中</li><li>设置类路径，类路径是所有包含类文件的路径的集合。在Unix环境中类路径中的各项用冒号分隔，在Windows环境中各项用分号分隔，两个环境都使用句点表示当前目录。类路径包括基目录、当前目录、JAR文件。从Java 6开始，可以为JAR文件目录指定一个通配符，通配符下的所有JAR文件都会包含在这个类路径中。由于总是会搜索Java API的类，所以不需要显式地包含在类路径中。</li></ol><blockquote><p>Java编译器总是在当前目录中查找文件，但只有当类路径中包含当前目录时Java虚拟机才会查看当前目录。如果没有设置类路径那么会默认包含当前目录，否则必须显式指定当前目录。</p></blockquote><p>类路径列出的目录和归档文件是搜寻类的起始点。</p><h3 id="_1-7-7-设置类路径" tabindex="-1"><a class="header-anchor" href="#_1-7-7-设置类路径"><span>1.7.7 设置类路径</span></a></h3><p>最好使用 <code>-classpath</code> 或 <code>-cp</code> 或者Java 9中的 <code>--class-path</code> 选项指定类路径，整个指令必须放在同一行，可以选择把这样的命令行放在一个shell脚本或者批处理文件中。</p><p>另一种方式是通过设置CLASSPATH环境变量来指定类路径。</p><p>在Java 9中还可以从模块路径加载类。</p><h2 id="_1-8-jar文件" tabindex="-1"><a class="header-anchor" href="#_1-8-jar文件"><span>1.8 JAR文件</span></a></h2><p>JAR文件可以理解为打包好的应用程序，其内部包含类文件和其他资源文件，它使用ZIP压缩格式。</p><h3 id="_1-8-1-创建jar文件" tabindex="-1"><a class="header-anchor" href="#_1-8-1-创建jar文件"><span>1.8.1 创建JAR文件</span></a></h3><p>可以使用jar工具制作JAR文件，可以将应用程序和代码库打包在JAR文件中。</p><p>当然也可以使用IDE提供的功能打包JAR文件。</p><h3 id="_1-8-2-清单文件" tabindex="-1"><a class="header-anchor" href="#_1-8-2-清单文件"><span>1.8.2 清单文件</span></a></h3><p>除了类文件和资源文件外，每个JAR文件还包含一个清单文件，用于描述归档文件的特殊特性。</p><p>清单文件被命名为 <code>MANIFEST.MF</code> ，它位于JAR文件的一个特殊子目录 <code>META-INF</code> 子目录中。合法的最小清单文件只有一行</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">Manifest-Version: 1.0</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>复杂的清单文件可能包含更多条目，这些条目被分组为多个节，第一节称为主节，它作用于整个JAR文件。随后的条目可以指定命名实体的属性，如单个文件、包或者URL，他们都必须以一个Name条目开始。节与节之间用空行分隔开。</p><h3 id="_1-8-3-可执行jar文件" tabindex="-1"><a class="header-anchor" href="#_1-8-3-可执行jar文件"><span>1.8.3 可执行JAR文件</span></a></h3><p>可以使用jar命令指定程序的入口点，或者可以在清单文件中指定程序的主类，不需要为主类加扩展名。最后还可以将JAR文件打包成exe可执行文件，方便运行。</p><h3 id="_1-8-4-多版本jar文件" tabindex="-1"><a class="header-anchor" href="#_1-8-4-多版本jar文件"><span>1.8.4 多版本JAR文件</span></a></h3><p>Java 9引入了多版本JAR以确保不同版本的Java使用合适的库文件。</p><p>为了保证向后兼容，特定于版本的类文件放在 <code>META-INF/versions</code> 目录中。</p><p>多版本JAR并不适用于不同版本的程序或库，对于不同的版本，所有类的公共API都应该是一样的。多版本JAR的唯一作用是使某个特定版本的程序或库能够使用多个不同的JDK版本。如果增加了功能或者改变了某个API就应当提供一个新版本的JAR。</p><h2 id="_1-9-文档注释" tabindex="-1"><a class="header-anchor" href="#_1-9-文档注释"><span>1.9 文档注释</span></a></h2><p>JDK包含的Javadoc工具可以由源文件生成一个HTML文档，如果在源代码中添加 <code>/**</code> 开始的注释，那么就可以使用Javadoc工具生成漂亮的注释文档。</p><h3 id="_1-9-1-注释的插入" tabindex="-1"><a class="header-anchor" href="#_1-9-1-注释的插入"><span>1.9.1 注释的插入</span></a></h3><p>Javadoc将从下面几项中抽取信息：</p><ol><li>模块</li><li>包</li><li>公共类与接口</li><li>公共的和受保护的字段</li><li>公共的和受保护的构造器及方法</li></ol><p>可以为以上各个特性编写注释，各个注释放置在所描述的特性的前面，注释以 <code>/**</code> 开始，以 <code>*/</code> 结束。每个文档注释包含标记以及紧跟其后的自由格式文本，标记以 <code>@</code> 开始。自由格式文本的第一个句子应该是概要陈述，Javadoc工具自动将这些句子抽取出来生成概要页。在自由格式文本中可以使用HTML修饰符。如果文档中有到其他文件的链接，应该把这些文件放到包含源文件的目录下的一个子目录 <code>doc-files</code> 中，Javadoc工具将从源目录将 <code>doc-files</code> 目录及其内容复制到文档目录中。在文档中需要使用 <code>doc-files</code> 目录。</p><h3 id="_1-9-2-类注释" tabindex="-1"><a class="header-anchor" href="#_1-9-2-类注释"><span>1.9.2 类注释</span></a></h3><p>类注释必须放在 <code>import</code> 语句之后， <code>class</code> 定义之前。例如下面的注释</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token doc-comment comment">/**</span>
<span class="line"> * A <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token class-name">Card</span></span></span><span class="token punctuation">}</span> object represents a playing card, such</span>
<span class="line"> * as &quot;Queen of Hearts&quot;. A card has a suit (Diamond, Heart,</span>
<span class="line"> * Spade or Club) and a value (1 = Ace, 2 . . . 10, 11 = Jack,</span>
<span class="line"> * 12 = Queen, 13 = King)</span>
<span class="line"> */</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Card</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-9-3-方法注释" tabindex="-1"><a class="header-anchor" href="#_1-9-3-方法注释"><span>1.9.3 方法注释</span></a></h3><p>每个方法注释都必须放在所描述的方法之前，除了通用标记以外还可以使用以下标记</p><ul><li><code>@param variable description</code></li><li><code>@return description</code></li><li><code>@throws class description</code></li></ul><p>分别表示参数、返回值和抛出异常的注释。描述可以占据多行并且可以使用HTML标记，一个方法的所有 <code>@param</code> 标记必须放在一起。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token doc-comment comment">/**</span>
<span class="line"> * Raises the salary of an employee.</span>
<span class="line"> * <span class="token keyword">@param</span>  <span class="token parameter">byPercent</span> the percentage by which to raise the salary (e.g., 10 means 10%)</span>
<span class="line"> * <span class="token keyword">@return</span>  the amount of the raise</span>
<span class="line"> */</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">raiseSalary</span><span class="token punctuation">(</span><span class="token keyword">double</span> byPercent<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">double</span> raise <span class="token operator">=</span> salary <span class="token operator">*</span> byPercent <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">;</span></span>
<span class="line">    salary <span class="token operator">+=</span> raise<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span> raise<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-9-4-字段注释" tabindex="-1"><a class="header-anchor" href="#_1-9-4-字段注释"><span>1.9.4 字段注释</span></a></h3><p>只需要对公共字段，通常指静态常量，增加文档注释。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token doc-comment comment">/**</span>
<span class="line"> * The &quot;Hearts&quot; card suit</span>
<span class="line"> */</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">HEARTS</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-9-5-通用注释" tabindex="-1"><a class="header-anchor" href="#_1-9-5-通用注释"><span>1.9.5 通用注释</span></a></h3><ul><li><code>@since text</code> 会建立一个 <code>since</code> 条目，文本可以是对引入这个特性的版本的描述。如 <code>@since 1.7.1</code> 。</li><li><code>@author name</code> 用于跟踪作者。</li><li><code>@version text</code> 标记将建立一个 <code>version</code> 条目，文本可以是对当前版本的任何描述。</li><li>通过 <code>@see</code> 和 <code>@link</code> 标记可以使用超链接，链接到Javadoc文档的相关部分或外部文档。</li><li>在Java 9中还可以使用 <code>{@index entry}</code> 标记为搜索框增加一个条目。</li></ul><h3 id="_1-9-6-包注释" tabindex="-1"><a class="header-anchor" href="#_1-9-6-包注释"><span>1.9.6 包注释</span></a></h3><p>要想产生包注释需要在每一个包目录中添加一个单独的文件，有以下两个选择</p><ol><li>提供一个名为 <code>package-info.java</code> 的Java文件，这个文件必须包含一个初始的Javadoc注释，以 <code>/**</code> 和 <code>*/</code> 界定，后面是一个 <code>package</code> 语句，不能再包含更多的代码或注释。</li><li>提供一个名为 <code>package.html</code> 的HTML文件，抽取标记 <code>&lt;body&gt;...&lt;/body&gt;</code> 中的所有文本。</li></ol><h3 id="_1-9-7-注释提取" tabindex="-1"><a class="header-anchor" href="#_1-9-7-注释提取"><span>1.9.7 注释提取</span></a></h3><p>执行以下步骤</p><ol><li>切换到包含想要生成文档的源文件所在目录</li><li>运行相关命令</li></ol><p>具体请查阅Javadoc工具的联机文档</p><h2 id="_1-10-类设计技巧" tabindex="-1"><a class="header-anchor" href="#_1-10-类设计技巧"><span>1.10 类设计技巧</span></a></h2><p>设计类时需要注意以下几点</p><ol><li>确保数据私有。</li><li>确保初始化数据。</li><li>不要在类中使用过多的基本类型，可以创建其他类对字段进行封装。</li><li>不是所有的字段都需要单独的字段访问器和修改器。</li><li>分解有过多职责的类。</li><li>合理命名。类名应该是名词或名词性短语，访问器方法用小写get开头，更改器方法用小写set开头。</li><li>优先使用不可变的类</li></ol>`,171)]))}const o=n(l,[["render",c],["__file","Javamianxiangduixiangchengxusheji——duixiangyulei.html.vue"]]),d=JSON.parse('{"path":"/blogs/Java/Javamianxiangduixiangchengxusheji——duixiangyulei.html","title":"对象与类","lang":"en-US","frontmatter":{"title":"对象与类","categories":["Java"]},"headers":[{"level":2,"title":"1.1 基本概念和要求","slug":"_1-1-基本概念和要求","link":"#_1-1-基本概念和要求","children":[]},{"level":2,"title":"1.2 创建类","slug":"_1-2-创建类","link":"#_1-2-创建类","children":[{"level":3,"title":"1.2.1 构造器","slug":"_1-2-1-构造器","link":"#_1-2-1-构造器","children":[]},{"level":3,"title":"1.2.2 使用null引用","slug":"_1-2-2-使用null引用","link":"#_1-2-2-使用null引用","children":[]},{"level":3,"title":"1.2.3 隐式参数","slug":"_1-2-3-隐式参数","link":"#_1-2-3-隐式参数","children":[]},{"level":3,"title":"1.2.4 封装的优点","slug":"_1-2-4-封装的优点","link":"#_1-2-4-封装的优点","children":[]},{"level":3,"title":"1.2.5 基于类的访问权限","slug":"_1-2-5-基于类的访问权限","link":"#_1-2-5-基于类的访问权限","children":[]},{"level":3,"title":"1.2.6 私有方法","slug":"_1-2-6-私有方法","link":"#_1-2-6-私有方法","children":[]},{"level":3,"title":"1.2.7 final实例字段","slug":"_1-2-7-final实例字段","link":"#_1-2-7-final实例字段","children":[]}]},{"level":2,"title":"1.3 静态字段与静态方法","slug":"_1-3-静态字段与静态方法","link":"#_1-3-静态字段与静态方法","children":[{"level":3,"title":"1.3.1 静态字段与静态常量","slug":"_1-3-1-静态字段与静态常量","link":"#_1-3-1-静态字段与静态常量","children":[]},{"level":3,"title":"1.3.2 静态方法","slug":"_1-3-2-静态方法","link":"#_1-3-2-静态方法","children":[]},{"level":3,"title":"1.3.3 工厂方法","slug":"_1-3-3-工厂方法","link":"#_1-3-3-工厂方法","children":[]},{"level":3,"title":"1.3.4 main方法","slug":"_1-3-4-main方法","link":"#_1-3-4-main方法","children":[]}]},{"level":2,"title":"1.4 方法参数","slug":"_1-4-方法参数","link":"#_1-4-方法参数","children":[]},{"level":2,"title":"1.5 对象构造","slug":"_1-5-对象构造","link":"#_1-5-对象构造","children":[{"level":3,"title":"1.5.1 重载","slug":"_1-5-1-重载","link":"#_1-5-1-重载","children":[]},{"level":3,"title":"1.5.2 默认字段初始化","slug":"_1-5-2-默认字段初始化","link":"#_1-5-2-默认字段初始化","children":[]},{"level":3,"title":"1.5.3 无参数构造器","slug":"_1-5-3-无参数构造器","link":"#_1-5-3-无参数构造器","children":[]},{"level":3,"title":"1.5.4 显式字段初始化","slug":"_1-5-4-显式字段初始化","link":"#_1-5-4-显式字段初始化","children":[]},{"level":3,"title":"1.5.5 参数名","slug":"_1-5-5-参数名","link":"#_1-5-5-参数名","children":[]},{"level":3,"title":"1.5.6 调用另一个构造器","slug":"_1-5-6-调用另一个构造器","link":"#_1-5-6-调用另一个构造器","children":[]},{"level":3,"title":"1.5.7 初始化块","slug":"_1-5-7-初始化块","link":"#_1-5-7-初始化块","children":[]},{"level":3,"title":"1.5.8 对象析构","slug":"_1-5-8-对象析构","link":"#_1-5-8-对象析构","children":[]}]},{"level":2,"title":"1.6 记录","slug":"_1-6-记录","link":"#_1-6-记录","children":[{"level":3,"title":"1.6.1 概念","slug":"_1-6-1-概念","link":"#_1-6-1-概念","children":[]},{"level":3,"title":"1.6.2 构造器：标准、自定义和简洁","slug":"_1-6-2-构造器-标准、自定义和简洁","link":"#_1-6-2-构造器-标准、自定义和简洁","children":[]}]},{"level":2,"title":"1.7 包","slug":"_1-7-包","link":"#_1-7-包","children":[{"level":3,"title":"1.7.1 包名","slug":"_1-7-1-包名","link":"#_1-7-1-包名","children":[]},{"level":3,"title":"1.7.2 类的导入","slug":"_1-7-2-类的导入","link":"#_1-7-2-类的导入","children":[]},{"level":3,"title":"1.7.3 静态导入","slug":"_1-7-3-静态导入","link":"#_1-7-3-静态导入","children":[]},{"level":3,"title":"1.7.4 在包中增加类","slug":"_1-7-4-在包中增加类","link":"#_1-7-4-在包中增加类","children":[]},{"level":3,"title":"1.7.5 包访问","slug":"_1-7-5-包访问","link":"#_1-7-5-包访问","children":[]},{"level":3,"title":"1.7.6 类路径","slug":"_1-7-6-类路径","link":"#_1-7-6-类路径","children":[]},{"level":3,"title":"1.7.7 设置类路径","slug":"_1-7-7-设置类路径","link":"#_1-7-7-设置类路径","children":[]}]},{"level":2,"title":"1.8 JAR文件","slug":"_1-8-jar文件","link":"#_1-8-jar文件","children":[{"level":3,"title":"1.8.1 创建JAR文件","slug":"_1-8-1-创建jar文件","link":"#_1-8-1-创建jar文件","children":[]},{"level":3,"title":"1.8.2 清单文件","slug":"_1-8-2-清单文件","link":"#_1-8-2-清单文件","children":[]},{"level":3,"title":"1.8.3 可执行JAR文件","slug":"_1-8-3-可执行jar文件","link":"#_1-8-3-可执行jar文件","children":[]},{"level":3,"title":"1.8.4 多版本JAR文件","slug":"_1-8-4-多版本jar文件","link":"#_1-8-4-多版本jar文件","children":[]}]},{"level":2,"title":"1.9 文档注释","slug":"_1-9-文档注释","link":"#_1-9-文档注释","children":[{"level":3,"title":"1.9.1 注释的插入","slug":"_1-9-1-注释的插入","link":"#_1-9-1-注释的插入","children":[]},{"level":3,"title":"1.9.2 类注释","slug":"_1-9-2-类注释","link":"#_1-9-2-类注释","children":[]},{"level":3,"title":"1.9.3 方法注释","slug":"_1-9-3-方法注释","link":"#_1-9-3-方法注释","children":[]},{"level":3,"title":"1.9.4 字段注释","slug":"_1-9-4-字段注释","link":"#_1-9-4-字段注释","children":[]},{"level":3,"title":"1.9.5 通用注释","slug":"_1-9-5-通用注释","link":"#_1-9-5-通用注释","children":[]},{"level":3,"title":"1.9.6 包注释","slug":"_1-9-6-包注释","link":"#_1-9-6-包注释","children":[]},{"level":3,"title":"1.9.7 注释提取","slug":"_1-9-7-注释提取","link":"#_1-9-7-注释提取","children":[]}]},{"level":2,"title":"1.10 类设计技巧","slug":"_1-10-类设计技巧","link":"#_1-10-类设计技巧","children":[]}],"git":{"createdTime":1726994140000,"updatedTime":1726994140000,"contributors":[{"name":"gitDebuger","email":"hygchn04@gmail.com","commits":1}]},"filePathRelative":"blogs/Java/Java面向对象程序设计——对象与类.md"}');export{o as comp,d as data};
