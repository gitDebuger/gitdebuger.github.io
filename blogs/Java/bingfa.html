<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-rc.14">
    <script>
      (function() {
        const userMode = localStorage.getItem('vuepress-reco-color-scheme') || 'auto';
        const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (userMode === 'dark' || (userMode === 'auto' && systemDarkMode)) {
          document.documentElement.classList.toggle('dark', true);
        }
      })();
    </script>
    <title>并发 | Yunge Hu 's Blog</title><meta name="description" content="Just playing around">
    <link rel="preload" href="/assets/style-DFiSfBVn.css" as="style"><link rel="stylesheet" href="/assets/style-DFiSfBVn.css">
    <link rel="modulepreload" href="/assets/app-B51tXhJU.js"><link rel="modulepreload" href="/assets/bingfa.html-BObwH6f-.js">
    <link rel="prefetch" href="/assets/timeline.html-CDRCyYXN.js" as="script"><link rel="prefetch" href="/assets/posts.html-Cm3Bj9S1.js" as="script"><link rel="prefetch" href="/assets/friendship-link.html-CPYWbDf2.js" as="script"><link rel="prefetch" href="/assets/1.html-BvGA5exa.js" as="script"><link rel="prefetch" href="/assets/1.html-CQiPtbSY.js" as="script"><link rel="prefetch" href="/assets/1.html-B91OJGi4.js" as="script"><link rel="prefetch" href="/assets/1.html-Tfqc0eqa.js" as="script"><link rel="prefetch" href="/assets/1.html-DkR1aWCw.js" as="script"><link rel="prefetch" href="/assets/1.html-9JnLqyKk.js" as="script"><link rel="prefetch" href="/assets/2.html-Bgp2cdo4.js" as="script"><link rel="prefetch" href="/assets/3.html-BrEt4hPg.js" as="script"><link rel="prefetch" href="/assets/index.html-BKyJy_kV.js" as="script"><link rel="prefetch" href="/assets/Install-Neo4j-in-Ubuntu-and-Use-Gremlin.html-D3zJqoKu.js" as="script"><link rel="prefetch" href="/assets/Neo4j.html-RU17f5ie.js" as="script"><link rel="prefetch" href="/assets/index.html-DTD_Tf27.js" as="script"><link rel="prefetch" href="/assets/README.zh.html-C95KaJWV.js" as="script"><link rel="prefetch" href="/assets/Javajibenchengxushejijiegou.html-Cop84p5k.js" as="script"><link rel="prefetch" href="/assets/Javamianxiangduixiangchengxusheji——duixiangyulei.html-RHrWrJ8D.js" as="script"><link rel="prefetch" href="/assets/Javamianxiangduixiangchengxusheji——jiekou、lambdabiaodashiyunabulei.html-B4BIhUeh.js" as="script"><link rel="prefetch" href="/assets/Javamianxiangduixiangchengxusheji——jicheng.html-CDNHmPwq.js" as="script"><link rel="prefetch" href="/assets/yichangduanyanherizhi.html-Bw2Q646T.js" as="script"><link rel="prefetch" href="/assets/fanxingyujihe.html-ChyCepcN.js" as="script"><link rel="prefetch" href="/assets/index.html-B_tI2L4g.js" as="script"><link rel="prefetch" href="/assets/suoyincaozuo.html-M9SgPFiv.js" as="script"><link rel="prefetch" href="/assets/lab0.html-DQt1B-xd.js" as="script"><link rel="prefetch" href="/assets/lab1.html-Dvm30kLN.js" as="script"><link rel="prefetch" href="/assets/lab2.html-gAWXyUFt.js" as="script"><link rel="prefetch" href="/assets/lab3.html-LQVGolsr.js" as="script"><link rel="prefetch" href="/assets/lab4.html-CF_2B461.js" as="script"><link rel="prefetch" href="/assets/lab5.html-2WxLf5I9.js" as="script"><link rel="prefetch" href="/assets/lab6.html-ueb45YH9.js" as="script"><link rel="prefetch" href="/assets/index.html-CjBzVZj0.js" as="script"><link rel="prefetch" href="/assets/404.html-Dk0UZDtj.js" as="script"><link rel="prefetch" href="/assets/Valine.min-Dm4Ijz6H.js" as="script"><link rel="prefetch" href="/assets/giscus-2a044aea-CdPDkb7_.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container series--no show-catalog"><header class="navbar-container not-open"><div class="navbar-inner"><div class="site-brand nav-item"><img class="logo" src="/logo.png" alt="Yunge Hu &#39;s Blog"><a href="/" class="site-name can-hide">Yunge Hu &#39;s Blog</a></div><div class="nav-item navbar-links-wrapper" style=""><div><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div><nav class="navbar-links"><!--[--><div class="navbar-links__item"><a href="/" class="link router-link-active" aria-label="Home"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->Home<!--]--></span></span><!--[--><!--]--></a></div><div class="navbar-links__item"><a class="link" href="https://github.com/gitDebuger/gitdebuger.github.io" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->GitHub<!--]--></span></span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><span class="xicon-container btn-toggle-dark-mode btn--dark-mode"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 32 32" style="width:20px;height:20px;font-size:20px;color:inherit;"><path d="M15 2h2v3h-2z" fill="currentColor"></path><path d="M27 15h3v2h-3z" fill="currentColor"></path><path d="M15 27h2v3h-2z" fill="currentColor"></path><path d="M2 15h3v2H2z" fill="currentColor"></path><path d="M5.45 6.884l1.414-1.415l2.121 2.122l-1.414 1.414z" fill="currentColor"></path><path d="M23 7.58l2.121-2.12l1.414 1.414l-2.121 2.121z" fill="currentColor"></path><path d="M23.002 24.416l1.415-1.414l2.12 2.122l-1.413 1.414z" fill="currentColor"></path><path d="M5.47 25.13L7.59 23L9 24.42l-2.12 2.12l-1.41-1.41z" fill="currentColor"></path><path d="M16 8a8 8 0 1 0 8 8a8 8 0 0 0-8-8zm0 14a6 6 0 0 1 0-12z" fill="currentColor"></path></svg></span><span class="xicon-container btn-toggle-menus"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 32 32" style="width:20px;height:20px;font-size:20px;color:inherit;"><circle cx="16" cy="8" r="2" fill="currentColor"></circle><circle cx="16" cy="16" r="2" fill="currentColor"></circle><circle cx="16" cy="24" r="2" fill="currentColor"></circle></svg></span></div></div></header><!----><!----><!----><!--[--><main class="page-container"><aside class="series-container"><!--[--><!--]--></aside><div class="page-content"><h1 class="page-title">并发</h1><div class="page-info"><span class="xicon-container left"><!--[--><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 32 32" class="xicon-icon" style="width:18px;height:18px;font-size:18px;color:inherit;"><path d="M16 4a5 5 0 1 1-5 5a5 5 0 0 1 5-5m0-2a7 7 0 1 0 7 7a7 7 0 0 0-7-7z" fill="currentColor"></path><path d="M26 30h-2v-5a5 5 0 0 0-5-5h-6a5 5 0 0 0-5 5v5H6v-5a7 7 0 0 1 7-7h6a7 7 0 0 1 7 7z" fill="currentColor"></path></svg><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->Yunge Hu<!--]--></span></span><!----><span class="xicon-container left"><!--[--><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 32 32" class="xicon-icon" style="width:18px;height:18px;font-size:18px;color:inherit;"><path d="M11.17 6l3.42 3.41l.58.59H28v16H4V6h7.17m0-2H4a2 2 0 0 0-2 2v20a2 2 0 0 0 2 2h24a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2H16l-3.41-3.41A2 2 0 0 0 11.17 4z" fill="currentColor"></path></svg><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[--><!--[--><a href="/categories/Java/1.html" class="">Java</a><!--]--><!--]--></span></span><!----><!----></div><div class="theme-reco-md-content"><div><h1 id="_1-并发" tabindex="-1"><a class="header-anchor" href="#_1-并发"><span>1. 并发</span></a></h1><p>多任务是操作系统的一种能力，看起来可以在同一时刻运行多个程序。并发执行的进程数不限于CPU数或CPU核心数，操作系统会为每个进程分配CPU时间片，给人并行处理的感觉。</p><p>多线程程序扩展了多任务的概念，单个程序看起来在同时完成多个任务。每个任务在一个线程执行，线程是控制线程的简称。</p><p>多进程和多线程本质的区别在于，每个进程都拥有自己的一套变量，线程之间则共享数据。尽管共享数据可能会导致安全性问题，但是共享数据使得线程之间的通信更高效和更容易。此外，线程更轻量级，资源消耗比进程小。</p><h2 id="_1-1-什么是线程" tabindex="-1"><a class="header-anchor" href="#_1-1-什么是线程"><span>1.1. 什么是线程</span></a></h2><p>创建线程并运行的方法如下：</p><ol><li><p>将执行某个任务的代码放在某个实现了 <code>Runnable</code> 接口的类的 <code>run</code> 方法中。 <code>Runnable</code> 接口只有一个方法：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于 <code>Runnable</code> 接口是一个函数式接口，所以也可以使用 lambda 表达式创建一个实例：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>从这个 <code>Runnable</code> 构造一个 <code>Thread</code> 对象：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>启动线程：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line">t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ol><p>注意：不要调用 <code>Thread</code> 类或者 <code>Runnable</code> 对象的 <code>run</code> 方法，直接调用 <code>run</code> 方法只会在同一线程执行这个任务，而没有启动新的线程。只有调用 <code>Thread.start</code> 方法才会创建新的线程执行 <code>run</code> 方法。</p><h2 id="_1-2-线程状态" tabindex="-1"><a class="header-anchor" href="#_1-2-线程状态"><span>1.2. 线程状态</span></a></h2><p>线程可以有六种状态：</p><ul><li><strong>New</strong></li><li><strong>Runnable</strong></li><li><strong>Blocked</strong></li><li><strong>Waiting</strong></li><li><strong>Timed waiting</strong></li><li><strong>Terminated</strong></li></ul><p>要确定一个线程的状态，可以调用 <code>getState</code> 方法。</p><h3 id="_1-2-1-新建线程" tabindex="-1"><a class="header-anchor" href="#_1-2-1-新建线程"><span>1.2.1. 新建线程</span></a></h3><p>用 <code>new</code> 操作符创建一个线程时，这个线程还没有运行，这时它的状态就是新建，即 <strong>new</strong> 。</p><h3 id="_1-2-2-可运行线程" tabindex="-1"><a class="header-anchor" href="#_1-2-2-可运行线程"><span>1.2.2. 可运行线程</span></a></h3><p>一旦调用 <code>start</code> 方法，线程就处于可运行状态，即 <strong>runnable</strong> 状态。</p><p>一个可运行的线程可能正在运行，也可能没有在运行，操作系统会为线程提供具体的运行时间。</p><blockquote><p>抢占式调度（Preemptive Scheduling）和协作式调度（Cooperative Scheduling）是操作系统中用于管理多个任务或线程的两种不同调度策略，它们决定了何时和如何分配处理器时间给不同的任务。</p><p><strong>1. 抢占式调度（Preemptive Scheduling）：</strong></p><p>抢占式调度是一种操作系统调度策略，其中操作系统具有高度的控制权，可以在任务执行期间强制将处理器资源从一个任务切换到另一个任务。这种切换通常发生在任务达到其时间片（一段固定时间）的末尾或在高优先级任务准备执行时。</p><p>优点：</p><ul><li>允许操作系统对任务的优先级进行管理，以确保关键任务能够及时执行。</li><li>避免了某个任务长时间占用处理器资源，导致其他任务无法响应。</li></ul><p>缺点：</p><ul><li>需要额外的调度开销，因为需要频繁地切换任务。</li><li>可能会引入竞争条件和死锁等问题，需要仔细管理。</li></ul><p><strong>2. 协作式调度（Cooperative Scheduling）：</strong></p><p>协作式调度是一种调度策略，其中任务或线程自愿地释放处理器资源。在这种策略下，任务通常在执行期间主动让出处理器，以便其他任务能够运行。协作式调度依赖于任务的合作，因此如果一个任务不合作或发生无限循环等情况，可能会导致系统停滞。</p><p>优点：</p><ul><li>相对简单，没有抢占式调度的开销。</li><li>适用于某些特定情况下，如实时系统或嵌入式系统。</li></ul><p>缺点：</p><ul><li>不适用于所有情况，因为它依赖于任务的自愿合作，可能会导致不公平分配和响应时间延迟。</li><li>如果有一个任务无限期地占用处理器，可能会导致整个系统停滞。</li></ul><p>总结：</p><p>抢占式调度和协作式调度各有其用途。抢占式调度适用于多任务环境中，其中任务需要按照其优先级获得处理器时间，并且需要及时响应外部事件。协作式调度通常在某些特定环境中使用，例如嵌入式系统或某些应用程序，其中任务的运行行为可以更精确地控制。选择哪种调度策略取决于系统需求和设计目标。</p></blockquote><p>在 <code>java.util.Thread</code> 类中有一个 <code>static void yield()</code> 方法，它会使当前正在执行的线程向另一个线程交出运行权。</p><h3 id="_1-2-3-阻塞和等待线程" tabindex="-1"><a class="header-anchor" href="#_1-2-3-阻塞和等待线程"><span>1.2.3. 阻塞和等待线程</span></a></h3><p>当线程处于等待或阻塞状态时，它暂时是不活动的，它不执行任何代码并且消耗最少的资源，需要线程调度器重新激活这个线程。具体细节取决于它是怎样到达非活动状态的。</p><ul><li><p><strong>阻塞：</strong></p><p>当一个线程试图获取一个内部的对象锁，而这个锁目前被其他线程占有时，该线程就会被阻塞。当所有其他线程都释放了这个锁，并且线程调度器允许该线程持有这个锁时，它将会变成非阻塞状态。</p></li><li><p><strong>等待</strong></p><p>当线程等待另一个线程通知调度器出现某个条件时，这个线程会进入等待状态。</p></li><li><p><strong>超时等待</strong></p><p>有几个方法有超时参数，调用这些方法会让线程进入计时等待状态，这一状态将一直保持到超时期满或者接收到适当的通知。</p></li></ul><p>当一个线程阻塞或等待时，可以调度另一个线程运行。当一个线程被重新激活时，调度器会检查它是否具有比当前运行线程更高的优先级，如果是这样，调度器会剥夺当前某个正在运行的线程的运行权，选择运行一个新线程。</p><h3 id="_1-2-4-终止线程" tabindex="-1"><a class="header-anchor" href="#_1-2-4-终止线程"><span>1.2.4. 终止线程</span></a></h3><p>线程会由于以下两个原因之一终止：</p><ol><li>由于 <code>run</code> 方法正常退出，线程自然终止；</li><li>由于一个没有捕获的异常终止了 <code>run</code> 方法，现成意外终止。</li></ol><blockquote><p>不要调用已经被废弃的 <code>stop</code> 方法终止线程。</p></blockquote><h2 id="_1-3-线程属性" tabindex="-1"><a class="header-anchor" href="#_1-3-线程属性"><span>1.3 线程属性</span></a></h2><h3 id="_1-3-1-中断线程" tabindex="-1"><a class="header-anchor" href="#_1-3-1-中断线程"><span>1.3.1 中断线程</span></a></h3><p>除了已经废弃的 <code>stop</code> 方法，没有办法强制一个线程终止。不过可以调用 <code>interrupt</code> 方法请求终止一个线程。</p><p>当一个线程调用 <code>interrupt</code> 方法时，就会设置线程的中断状态，这是每个线程都有的 <code>boolean</code> 标志，每个线程都应该不时检查这个标志，以判断线程是否被中断。</p><p>要确定是否设置了中断状态，首先调用静态方法 <code>Thread.currentThread</code> 获得当前线程，然后调用 <code>isInterrupted</code> 方法：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是如果线程被阻塞，就无法检查中断状态。在一个被 <code>sleep</code> 或 <code>wait</code> 调用阻塞或等待的线程上调用 <code>interrupt</code> 方法时，那个阻塞或等待调用将被 <code>InterruptedException</code> 异常中断。</p><blockquote><p>有一些阻塞 I/O 调用不能被中断，对此应考虑选择可以中断的调用。</p></blockquote><p>被中断的线程可以自行选择如何响应中断，某些线程非常重要，应该处理这个异常并继续执行；或者线程只希望将中断解释为终止请求，这种线程的 <code>run</code> 方法有如下形式：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token comment">// exit normally</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// thread was interrupted during sleep or wait</span></span>
<span class="line">        <span class="token comment">// exit unexpectedly</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">finally</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// cleanup, if required</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token comment">// exiting the run method terminates the thread</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果在每次工作迭代之后都调用 <code>sleep</code> 方法或其他可中断方法，那么 <code>isInterrupted</code> 检查就没有意义了。如果设置了中断状态并调用 <code>sleep</code> 方法，它不会休眠，而是会清除中断状态并抛出 <code>InterruptedException</code> 异常。在这种情况下，应该如下组织代码：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// !!!!!!!!!!!!!!!!!</span></span>
<span class="line">        <span class="token comment">// !!! look here !!!</span></span>
<span class="line">        <span class="token comment">// !!!!!!!!!!!!!!!!!</span></span>
<span class="line">        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token comment">// exit normally</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// thread was interrupted during sleep or wait</span></span>
<span class="line">        <span class="token comment">// exit unexpectedly</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">finally</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// cleanup, if required</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token comment">// exiting the run method terminates the thread</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>有两个类似的方法，分别是 <code>interrupted</code> 和 <code>isInterrupted</code> 方法，前者是静态方法，它检查当前线程是否中断，并且会清除该线程的中断状态。而后者是一个实例方法，可以用来检查是否有线程被中断，它不会改变中断状态。</p></blockquote><p>有些代码在底层抑制了 <code>InterruptedException</code> 异常，这样做是不合适的。如果实在想不到在 <code>catch</code> 子句中做什么有意义的工作，可以有两个选择：</p><ol><li>在 <code>catch</code> 子句中调用 <code>Thread.currentThread().interrupt()</code> 设置中断状态，以便调用者检测。</li><li>或者更好的选择是抛出这个异常，供调用者捕获这个异常并处理。</li></ol><h3 id="_1-3-2-守护线程" tabindex="-1"><a class="header-anchor" href="#_1-3-2-守护线程"><span>1.3.2 守护线程</span></a></h3><p>可以通过调用</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line">t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>将一个线程转换为守护线程，它的用途是为其他线程提供服务，例如计时器线程和清空过时缓存项的线程。只剩下守护线程时，虚拟机就会退出。</p><blockquote><p>这个方法必须在线程启动之前调用。</p></blockquote><h3 id="_1-3-3-线程名" tabindex="-1"><a class="header-anchor" href="#_1-3-3-线程名"><span>1.3.3 线程名</span></a></h3><p>可以使用 <code>setName</code> 方法为线程设置任何名字，不过即使不设置，线程也会有默认的名字。</p><p>这在线程转储时可能很有用。</p><h3 id="_1-3-4-未捕获异常的处理器" tabindex="-1"><a class="header-anchor" href="#_1-3-4-未捕获异常的处理器"><span>1.3.4 未捕获异常的处理器</span></a></h3><p>线程的 <code>run</code> 方法不能抛出任何检查型异常，非检查型异常可能会导致线程终止。这种情况下，线程会死亡。</p><h3 id="_1-3-5-线程优先级" tabindex="-1"><a class="header-anchor" href="#_1-3-5-线程优先级"><span>1.3.5 线程优先级</span></a></h3><p>线程具有优先级，可以使用 <code>setPriority</code> 方法设置线程优先级。</p><p>默认会继承创造它的线程的优先级。</p><p>线程优先级最低为 <code>MIN_PRIORITY</code> ，在 <code>Thread</code> 类中定义为 <code>1</code> ；最高为 <code>MAX_PRIORITY</code> ，定义为 <code>10</code> 。</p><p>同时 <code>NORM_PRIORITY</code> 定义为 <code>5</code> 。</p><p>线程调度器选择新线程时，优先选择优先级高的线程。</p><p>但是线程优先级高度依赖于系统。现在不建议使用线程优先级了。</p><h2 id="_1-4-同步" tabindex="-1"><a class="header-anchor" href="#_1-4-同步"><span>1.4 同步</span></a></h2><h3 id="_1-4-1-锁对象" tabindex="-1"><a class="header-anchor" href="#_1-4-1-锁对象"><span>1.4.1 锁对象</span></a></h3><p>Java 提供了 <code>ReentrantLock</code> 类用于实现锁，该类保护代码块的基本结构如下：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line">myLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// critical section</span></span>
<span class="line"><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span></span>
<span class="line">    mylock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个结构确保任何时刻只有一个线程进入临界区。</p><p>必须把解锁操作放在 <code>finally</code> 子句中，否则一旦锁没有释放，其他线程将永远阻塞。</p><p>使用锁不能使用 try-with-resources 语句。</p><p>每个对象都有自己的锁对象，锁对象可以保证串行化访问。</p><p>这个锁是可重入锁，线程可以反复获得已经拥有的锁。锁有一个持有计数，用于跟踪对 <code>lock</code> 方法的嵌套调用。</p><p>注意：要确保不能由于抛出异常语句而绕过临界区中的代码。如果在临界区代码结束之前中抛出异常，锁确实被释放，但是对象可能处于被破坏的状态。需要保证当前操作执行完毕后，其他线程能够正常访问这个对象。</p><p>关于这个锁对象还有一些特性，下面是来自 ChatGPT 的回答：</p><blockquote><p>ReentrantLock（可重入锁）是 Java 中用于实现锁的一个类，它提供了与 synchronized 关键字类似的功能，但更加灵活。ReentrantLock 是在 Java 5 中引入的，相比于 synchronized，它提供了更多的功能和更灵活的控制，例如可中断的锁、公平性选择等。</p><p>下面是 ReentrantLock 类的一些重要特性和用法：</p><ol><li><strong>可重入性</strong>：与 synchronized 关键字类似，ReentrantLock 支持线程对同一个锁的重入，即同一个线程可以多次获取同一把锁而不会造成死锁。这种机制对于递归函数或者一个方法内部调用其他加锁方法时非常有用。</li><li><strong>公平性选择</strong>：ReentrantLock 提供了公平锁和非公平锁两种模式。公平锁会按照请求的顺序来获取锁，而非公平锁则不保证获取锁的顺序。通过构造函数可以选择使用哪种模式，默认情况下是非公平锁。</li><li><strong>可中断性</strong>：ReentrantLock 提供了可中断的锁获取操作，即可以在等待锁的过程中中断线程。通过 lockInterruptibly() 方法可以实现可中断的锁获取。</li><li><strong>条件变量</strong>：ReentrantLock 提供了 Condition 接口及其实现类，用于在等待某个特定条件的线程之间进行通信。通过调用 ReentrantLock 的 newCondition() 方法可以获取一个与该锁相关联的 Condition 实例，然后可以使用 await()、signal()、signalAll() 方法来实现线程的等待和唤醒。</li><li><strong>tryLock() 方法</strong>：ReentrantLock 提供了 tryLock() 方法，用于尝试获取锁而不会一直等待。该方法会立即返回一个 boolean 值，表示是否获取到了锁。</li><li><strong>锁释放</strong>：ReentrantLock 与 synchronized 不同，它需要显式地释放锁。通常使用 try-finally 块来确保锁的释放，以避免因异常导致锁无法释放而造成死锁。</li></ol><p>总的来说，ReentrantLock 类提供了一种灵活、可重入、可中断、可选择公平性的锁机制，适用于对锁粒度、锁操作进行更精细控制的情况。</p></blockquote><h3 id="_1-4-2-条件对象" tabindex="-1"><a class="header-anchor" href="#_1-4-2-条件对象"><span>1.4.2 条件对象</span></a></h3><p>条件对象又被称为条件变量。</p><p>一个锁对象可以有一个或多个关联的条件对象。可以使用 <code>newCondition</code> 方法获得一个条件对象。</p><p>调用这个条件对象的 <code>await</code> 方法会让当前线程暂停并放弃锁，从而允许另一个线程执行。</p><p>调用这个方法的线程会进入这个条件的等待集，它会等到另一个线程在同一条件上调用 <code>signalAll</code> 方法。</p><p>这个调用会激活等待这个条件的所有线程，一旦锁可用，线程就会从 <code>await</code> 调用处返回并继续执行。</p><p>由于此时并不保证条件可用，所以还需要再次测试条件，所以 <code>await</code> 调用一般位于循环中：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token constant">OK</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最终必须有线程激活其他线程，否则有可能所有线程都被阻塞，程序永远挂起，造成死锁现象。</p><p>从经验上讲，只要一个对象的状态有变化，并且可能有利于正在等待的线程，就可以调用 <code>signalAll</code> 方法。</p><p>另一个方法 <code>signal</code> 会随机选择一个线程并激活，这个方法更高效但是存在一定危险，不能保证激活的线程可以正常运行。</p><p>实现同步机制会有效率损失。</p><h3 id="_1-4-3-示例代码" tabindex="-1"><a class="header-anchor" href="#_1-4-3-示例代码"><span>1.4.3 示例代码</span></a></h3><p>下面是使用锁对象和条件对象实现并发的示例代码：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">Condition</span></span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">Lock</span></span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">ReentrantLock</span></span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">SharedResource</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span></span>
<span class="line">        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token comment">// 等待 count 变为 0</span></span>
<span class="line">            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待条件满足</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">            <span class="token comment">// 执行增加操作</span></span>
<span class="line">            count<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Incremented: &quot;</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token comment">// 唤醒其他线程</span></span>
<span class="line">            condition<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span></span>
<span class="line">            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span></span>
<span class="line">        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token comment">// 等待 count 变为 1</span></span>
<span class="line">            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待条件满足</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">            <span class="token comment">// 执行减少操作</span></span>
<span class="line">            count<span class="token operator">--</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Decremented: &quot;</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token comment">// 唤醒其他线程</span></span>
<span class="line">            condition<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span></span>
<span class="line">            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">SharedResource</span> sharedResource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SharedResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token class-name">Thread</span> thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">                sharedResource<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token class-name">Thread</span> thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">                sharedResource<span class="token punctuation">.</span><span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-4-4-synchronized-关键字" tabindex="-1"><a class="header-anchor" href="#_1-4-4-synchronized-关键字"><span>1.4.4 synchronized 关键字</span></a></h3><p>每个对象都有一个内部锁，如果一个方法声明时有 <code>synchronized</code> 关键字，那么对象的锁将完整保护整个方法。</p><p>或者可以使用这个关键字保护某一段代码块。</p><p>两种结构如下：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 同步代码块</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 同步方法</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>内部对象锁只有一个关联条件，条件对象的 <code>await</code> &amp; <code>signal</code> &amp; <code>signalAll</code> 方法分别对应于 <code>wait</code> &amp; <code>notify</code> &amp; <code>notifyAll</code> 方法。</p><p>内部锁和条件存在使用限制：</p><ol><li>不能中断一个正在尝试获取锁的线程。</li><li>不能指定尝试获取锁的超时时间。</li><li>每个锁只有一个条件，这很低效。</li></ol><p>内部锁和条件灵活性不如前面的锁对象和条件对象，但是代码较为简洁，需要根据场景选择合适的方法。</p><p>下面是对同一场景的两种实现。</p><p>使用锁对象：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">Lock</span></span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">ReentrantLock</span></span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">CounterWithLock</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取锁</span></span>
<span class="line">        <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">            count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 执行计数器加一操作</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span></span>
<span class="line">            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放锁</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> count<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainWithLock</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">CounterWithLock</span> counter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CounterWithLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 创建多个线程并启动</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                    counter<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用计数器的增加方法</span></span>
<span class="line">                <span class="token punctuation">}</span></span>
<span class="line">            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 等待所有线程执行完毕</span></span>
<span class="line">        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 输出最终的计数值</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Count with Lock: &quot;</span> <span class="token operator">+</span> counter<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>synchronized</code> 关键字：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">CounterWithSynchronized</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 执行计数器加一操作</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> count<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainWithSynchronized</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">CounterWithSynchronized</span> counter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CounterWithSynchronized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 创建多个线程并启动</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                    counter<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用计数器的增加方法</span></span>
<span class="line">                <span class="token punctuation">}</span></span>
<span class="line">            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 等待所有线程执行完毕</span></span>
<span class="line">        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 输出最终的计数值</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Count with Synchronized: &quot;</span> <span class="token operator">+</span> counter<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于静态方法，会使用这个类的 <code>class</code> 对象的内部锁。</p><p>对于同步代码块，不要使用字符串字面量和基本类型包装器作为锁。</p><p>使用类的锁要从特定类上获得锁，而不是从 <code>getClass()</code> 方法获得锁。</p><p>有时会使用一个对象的锁来实现额外的原子操作，称为客户端锁定。不过客户端锁定是非常脆弱的，通常不建议使用。</p><h3 id="_1-4-5-监视器概念" tabindex="-1"><a class="header-anchor" href="#_1-4-5-监视器概念"><span>1.4.5 监视器概念</span></a></h3><p>在计算机科学中，监视器是一种并发编程的同步机制，用于确保多个线程能够安全地访问共享资源。监视器的概念最初由 C.A.R. Hoare 在他的经典论文中提出，后来被应用到了许多编程语言和操作系统中，其中包括 Java。</p><p>在 Java 中，每个对象都拥有一个内置的监视器（也称为锁），它用于实现对象的同步。这个内置的监视器可以通过 synchronized 关键字来进行访问和操作。当一个线程进入了一个使用 <code>synchronized</code> 关键字修饰的方法或代码块时，它就会获取该对象的监视器（锁），其他线程则会被阻塞，直到该线程执行完毕释放锁。</p><p>监视器的主要特点包括：</p><ol><li><strong>互斥性</strong>：一次只允许一个线程持有监视器（锁），其他线程必须等待锁释放后才能继续执行。</li><li><strong>条件等待</strong>：监视器可以关联一个或多个条件，线程可以在条件不满足时通过 <code>wait()</code> 方法进入等待状态，并在条件满足时通过 <code>notify()</code> 或 <code>notifyAll()</code> 方法唤醒等待的线程。</li><li><strong>原子性</strong>：监视器可以确保一系列操作的原子性，即一个线程在执行完毕释放锁之前，其他线程无法看到中间状态。</li></ol><p>监视器提供了一种简单而有效的同步机制，帮助开发者编写线程安全的代码。在 Java 中，监视器的内置实现使得并发编程变得更加容易，开发者可以通过 <code>synchronized</code> 关键字来实现对象级别的同步。</p><p>不过 Java 对象和监视器存在三点不同，削弱了线程安全性：</p><ol><li>字段不要求私有。</li><li>方法不要求同步。</li><li>内部锁对客户可用。</li></ol><h3 id="_1-4-6-volatile-字段" tabindex="-1"><a class="header-anchor" href="#_1-4-6-volatile-字段"><span>1.4.6 volatile 字段</span></a></h3><p>该关键字为实例字段的同步访问提供了一种免锁机制，如果将实例字段声明为 <code>volatile</code> 字段，那么编译器和虚拟机就会考虑到该字段可能并另一个线程并发更新。</p><p>但是 <code>volatile</code> 变量不能提供原子性。</p><p>下面是来自 ChatGPT 的介绍：</p><blockquote><p>在 Java 中，<code>volatile</code> 是一个关键字，用来修饰变量。当一个变量被 <code>volatile</code> 关键字修饰时，意味着这个变量的值可能会被多个线程同时修改，因此在访问这个变量时，线程会直接从内存中读取该变量的值，而不是从线程的工作内存中读取。此外，对于 <code>volatile</code> 变量的写操作也会立即同步到内存中，而不是延迟到线程切换时才进行。</p><p><code>volatile</code> 字段的主要特点包括：</p><ol><li><strong>可见性</strong>：当一个线程修改了 <code>volatile</code> 变量的值后，其他线程会立即看到最新的值，因为修改操作会直接同步到主内存中，其他线程读取时会直接从主内存中获取。</li><li><strong>禁止指令重排序</strong>：<code>volatile</code> 变量的写操作不仅保证了可见性，还会禁止指令重排序，即保证了 volatile 变量赋值操作的有序性。</li></ol><p>然而，需要注意的是，<code>volatile</code> 并不保证原子性。即使是 <code>volatile</code> 变量，在多线程环境下也可能会出现线程安全问题。如果需要保证原子性操作，例如对一个变量的读取-修改-写入操作是一个完整的原子操作，那么需要使用更强大的原子操作类，比如 <code>AtomicInteger</code>。</p><p>通常情况下，<code>volatile</code> 变量适用于以下场景：</p><ul><li>变量的写操作不依赖于变量的当前值，或者能够确保只有单个线程修改变量的值。</li><li>对变量的读操作不依赖于变量的当前值，或者能够确保读操作在变量被修改之后执行。</li></ul><p>总的来说，<code>volatile</code> 提供了一种简单而轻量级的线程间通信机制，用于确保变量的可见性和有序性，但在保证线程安全和原子性方面有限制。</p></blockquote><h3 id="_1-4-7-final-变量" tabindex="-1"><a class="header-anchor" href="#_1-4-7-final-变量"><span>1.4.7 final 变量</span></a></h3><p>对于对象的创建，如果将字段声明为 <code>final</code> 变量，那么其他线程会在对象的构造器完成构造之后才能看到这个变量。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">final</span> <span class="token keyword">var</span> counts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>否则其他线程可能看到的是 <code>null</code> 而不是新构造的对象。</p><h3 id="_1-4-8-原子性" tabindex="-1"><a class="header-anchor" href="#_1-4-8-原子性"><span>1.4.8 原子性</span></a></h3><p>如果对共享变量除了赋值之外不做其他操作，那么可以如上文所说将变量声明为 <code>volatile</code> 变量。</p><p>如果需要做更加复杂的操作，那么可以考虑使用 <code>java.util.concurrent.atomic</code> 包的类。</p><p>这些类提供了高效的机器指令来保证这些操作的原子性。</p><h3 id="_1-4-9-死锁" tabindex="-1"><a class="header-anchor" href="#_1-4-9-死锁"><span>1.4.9 死锁</span></a></h3><p>死锁是指在多线程或多进程的环境中，两个或多个线程或进程因为互相持有对方所需的资源而相互等待，导致它们都无法继续向前执行的情况。</p><p>要发生死锁，通常需要满足以下四个条件，这四个条件被称为死锁的必要条件：</p><ol><li><strong>互斥条件（Mutual Exclusion）</strong>：至少有一个资源是不能被共享的，只能由一个线程或进程独占。</li><li><strong>请求与保持条件（Hold and Wait）</strong>：一个线程或进程可以持有已经分配到的资源，并且可以请求新的资源。</li><li><strong>不可抢占条件（No Preemption）</strong>：系统中的资源只能由持有它的线程或进程释放，其他线程或进程无法强行抢占。</li><li><strong>循环等待条件（Circular Wait）</strong>：存在一个线程或进程的资源等待序列，使得每个线程或进程都在等待下一个线程或进程所持有的资源。</li></ol><p>当这些条件同时满足时，就可能导致死锁的发生。一旦发生死锁，各线程或进程都将永远等待下去，除非外部的干预打破了死锁的环境。</p><p>在多线程编程中，死锁是一种常见的问题，因此开发人员需要谨慎设计和管理多线程间的资源竞争，以避免死锁的发生。常见的解决死锁的方法包括：避免循环等待、按顺序申请资源、引入超时机制、死锁检测与恢复等。</p><p>在 Java 标准库中曾经存在 <code>stop</code> 方法和 <code>suspend</code> 方法，以及用来恢复 <code>suspend</code> 方法的 <code>resume</code> 方法。现在这些方法已经被废除，因为它们会造成不安全或者造成死锁现象。</p><h3 id="_1-4-10-线程局部变量" tabindex="-1"><a class="header-anchor" href="#_1-4-10-线程局部变量"><span>1.4.10 线程局部变量</span></a></h3><p>共享变量可能会存在问题。</p><p>不过有时可以避免共享变量，使用 <code>ThreadLocal</code> 辅助类为各自线程提供各自的实例。</p><p>可以使用这个辅助类为各自线程提供一个单独的生成器。</p><p>线程局部变量有时用于向协作完成某个任务的所有方法提供对象，而不必在调用者之间传递这个对象。</p><p>下面是来自 ChatGPT 的介绍：</p><blockquote><p>线程局部变量是一种在多线程环境下，每个线程都拥有自己独立的变量副本的机制。线程局部变量在 Java 中通过 <code>ThreadLocal</code> 辅助类来实现。</p><p><code>ThreadLocal</code> 是一个泛型类，在使用时需要指定变量的类型。它提供了一种线程绑定机制，使得每个线程都可以拥有自己的变量副本，而不会受到其他线程的影响。</p><p>下面是 <code>ThreadLocal</code> 类的一些主要方法和用法：</p><ol><li><strong>set(T value)</strong>：设置当前线程的变量副本的值为指定的值。</li><li><strong>T get()</strong>：获取当前线程的变量副本的值。</li><li><strong>remove()</strong>：移除当前线程的变量副本。</li></ol><p>线程局部变量的主要用途包括：</p><ul><li>避免线程安全问题：每个线程拥有自己的变量副本，不会受其他线程的影响，可以避免线程安全问题。</li><li>线程上下文信息传递：可以在多线程环境中方便地传递线程相关的上下文信息，而不需要显式地传递参数。</li><li>减少线程间共享资源的竞争：通过线程局部变量，可以减少线程之间对共享资源的竞争，提高程序性能。</li></ul><p>总的来说，<code>ThreadLocal</code> 辅助类提供了一种简单而有效的方式来实现线程局部变量，用于解决多线程环境下的线程安全和上下文传递等问题。</p></blockquote><h2 id="_1-5-线程安全的集合" tabindex="-1"><a class="header-anchor" href="#_1-5-线程安全的集合"><span>1.5 线程安全的集合</span></a></h2><h3 id="_1-5-1-阻塞队列" tabindex="-1"><a class="header-anchor" href="#_1-5-1-阻塞队列"><span>1.5.1 阻塞队列</span></a></h3><p>阻塞队列是一种线程安全的队列，它支持在队列为空或队列已满时进行阻塞等待的操作。阻塞队列常用于生产者-消费者模式中，可以有效地进行线程间的数据交换和协作。</p><p>Java 提供了 <code>BlockingQueue</code> 接口及其多个实现类，常见的包括：</p><ol><li><strong><code>LinkedBlockingQueue</code></strong>：基于链表实现的阻塞队列，可以指定容量，如果队列已满或队列为空时，插入元素或者取出元素的线程会阻塞。</li><li><strong><code>ArrayBlockingQueue</code></strong>：基于数组实现的阻塞队列，必须指定容量，如果队列已满或队列为空时，插入元素或者取出元素的线程会阻塞。</li><li><strong><code>PriorityBlockingQueue</code></strong>：基于优先级堆实现的无界阻塞队列，插入元素时会根据元素的优先级进行排序，取出元素时会取出优先级最高的元素。</li><li><strong><code>SynchronousQueue</code></strong>：一种特殊的阻塞队列，其内部没有存储元素的容量，每个插入操作必须等待一个对应的删除操作，反之亦然。通常用于线程之间的直接传输数据。</li></ol><p>阻塞队列的常用方法包括：</p><ul><li><strong><code>put(E e)</code></strong>：向队列尾部插入元素，如果队列已满，则阻塞直到队列有空闲空间。</li><li><strong><code>take()</code></strong>：从队列头部取出元素，如果队列为空，则阻塞直到队列有元素可取。</li><li><strong><code>offer(E e, long timeout, TimeUnit unit)</code></strong>：向队列尾部插入元素，在指定的超时时间内等待队列有空闲空间。</li><li><strong><code>poll(long timeout, TimeUnit unit)</code></strong>：从队列头部取出元素，在指定的超时时间内等待队列有元素可取。</li></ul><p>阻塞队列提供了一种方便且高效的方式来进行线程间的数据交换和协作，它可以避免手动实现线程间的等待/通知机制，从而简化了并发编程的复杂度。</p><h3 id="_1-5-2-映射-集-队列" tabindex="-1"><a class="header-anchor" href="#_1-5-2-映射-集-队列"><span>1.5.2 映射&amp;集&amp;队列</span></a></h3><ol><li><strong>映射（Map）</strong>： <ul><li><strong><code>ConcurrentHashMap</code></strong>：基于分段锁实现的线程安全的哈希表，可以在并发访问时保证线程安全。</li><li><strong><code>Hashtable</code></strong>：早期提供的线程安全的哈希表，使用 <code>synchronized</code> 来实现线程安全，但性能相对较差。</li></ul></li><li><strong>集合（Set/List）</strong>： <ul><li><strong><code>CopyOnWriteArrayList</code></strong>：线程安全的 <code>ArrayList</code>，采用写时复制的方式实现，适合读多写少的场景。</li><li><strong><code>CopyOnWriteArraySet</code></strong>：线程安全的 <code>HashSet</code>，基于 <code>CopyOnWriteArrayList</code> 实现。</li><li><strong><code>ConcurrentSkipListSet</code></strong>：基于跳表实现的线程安全的有序集合，支持高并发访问。</li><li><strong><code>ConcurrentSkipListMap</code></strong>：基于跳表实现的线程安全的有序映射。</li></ul></li><li><strong>队列（Queue）</strong>： <ul><li><strong><code>LinkedBlockingQueue</code></strong>：基于链表实现的线程安全的阻塞队列，支持无界队列和有界队列。</li><li><strong><code>ArrayBlockingQueue</code></strong>：基于数组实现的线程安全的阻塞队列，必须指定容量，支持有界队列。</li><li><strong><code>PriorityBlockingQueue</code></strong>：线程安全的优先级队列，基于优先级堆实现，支持高并发访问。</li><li><strong><code>ConcurrentLinkedQueue</code></strong>：基于链表实现的线程安全的无界队列，适用于高并发场景。</li></ul></li></ol><h3 id="_1-5-3-并行数组算法" tabindex="-1"><a class="header-anchor" href="#_1-5-3-并行数组算法"><span>1.5.3 并行数组算法</span></a></h3><p>Java 的 <code>java.util.Arrays</code> 类提供了一些用于操作数组的静态方法，其中包括一些并行化算法，这些算法利用了多线程来加速对数组的处理。主要的并行化算法包括 <code>parallelSort()</code> 方法。</p><ul><li><p><code>parallelSort()</code> 方法用于对数组进行并行排序。它会根据数组的类型和长度来选择合适的排序算法，并使用多线程来加速排序过程。</p></li><li><p>这个方法适用于对基本数据类型数组和对象数组进行排序。对于基本数据类型数组，它使用双轴快速排序算法来进行排序；对于对象数组，则使用归并排序算法。</p></li><li><p>使用并行化排序算法时，需要注意排序的数组规模和硬件环境，因为并行化排序算法可能会在小规模数组上带来额外的性能开销。</p></li><li><p>例如：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">parallelSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 对数组进行并行排序</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>除了 <code>parallelSort()</code> 方法之外，<code>java.util.Arrays</code> 类还提供了其他一些用于数组操作的静态方法，如 <code>parallelPrefix()</code>, <code>parallelSetAll()</code> 等，它们也可以在一定程度上利用并行化来提高性能。这些方法在处理大规模数组时可能会更有效地利用多核处理器的性能，从而加速数组处理过程。</p><h2 id="_1-6-任务和线程池" tabindex="-1"><a class="header-anchor" href="#_1-6-任务和线程池"><span>1.6 任务和线程池</span></a></h2><p>线程池中包含很多准备运行的线程，为线程池提供一个 <code>Runnable</code> 对象，其中会有一个线程执行这个 <code>run</code> 方法。当 <code>run</code> 方法结束后，这个线程不会死亡，而是留在线程池中等待运行下一个任务。</p><h3 id="_1-6-1-callable-和-future" tabindex="-1"><a class="header-anchor" href="#_1-6-1-callable-和-future"><span>1.6.1 Callable 和 Future</span></a></h3><p>在 Java 中，<code>Callable</code> 和 <code>Future</code> 是用于支持异步编程的接口和类。</p><p>它们通常与线程池一起使用，用于执行异步任务并获取任务执行结果。</p><ol><li><p><code>Callable</code> 接口</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">V</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该方法可以返回执行结果，并且允许抛出异常。</p><p>该方法执行异步任务的主体逻辑，并返回一个泛型类型的结果。</p></li><li><p><code>Future</code> 接口</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> mayInterrupt<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">boolean</span> <span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该接口表示一个异步计算的结果，它提供了方法来检查任务是否已经完成、等待任务的完成、取消任务的执行，并获取任务的执行结果。</p><p>对第一个 <code>get</code> 方法的调用会阻塞当前线程，直到计算结果完成。</p><p>对第二个 <code>get</code> 方法的调用同样会阻塞当前线程，如果调用超时，会抛出 <code>TimeoutException</code> 异常。</p><p>如果运行该计算的线程被中断，两个方法都会抛出 <code>InterruptedException</code> 异常。</p></li></ol><h3 id="_1-6-2-执行器" tabindex="-1"><a class="header-anchor" href="#_1-6-2-执行器"><span>1.6.2 执行器</span></a></h3><p><code>Executors</code> 类是 Java 并发包中用于创建和管理线程池的工厂类。它提供了一系列静态方法来创建不同类型的线程池，简化了线程池的创建和管理过程。</p><p>以下是 <code>Executors</code> 类的一些常用方法：</p><ol><li><p><strong><code>newFixedThreadPool(int nThreads)</code></strong>：</p><p>创建一个固定大小的线程池，该线程池中包含固定数量的线程。当线程池中的所有线程都处于活动状态时，新的任务会在等待队列中排队。</p></li><li><p><strong><code>newCachedThreadPool()</code></strong>：</p><p>创建一个根据需要自动调整大小的线程池。该线程池会根据任务的数量动态调整线程池的大小，当有新任务到来时，如果线程池中有空闲线程，则会复用空闲线程，否则会创建新的线程。</p></li><li><p><strong><code>newSingleThreadExecutor()</code></strong>：</p><p>创建一个单线程的线程池，该线程池中只包含一个线程，用于顺序执行任务。</p></li><li><p><strong><code>newScheduledThreadPool(int corePoolSize)</code></strong>：</p><p>创建一个固定大小的线程池，用于执行定时任务和周期性任务。</p></li><li><p><strong><code>newSingleThreadScheduledExecutor()</code></strong>：</p><p>创建一个单线程的线程池，用于执行定时任务和周期性任务。</p></li><li><p><strong><code>newWorkStealingPool()</code></strong>：</p><p>创建一个工作窃取线程池，线程池的大小根据 CPU 核心数自动调整，每个线程都维护自己的任务队列，可以从其他线程的队列中窃取任务执行。</p></li><li><p><strong><code>newFixedThreadPool(int nThreads, ThreadFactory threadFactory)</code></strong></p><p><strong><code>newCachedThreadPool(ThreadFactory threadFactory)</code></strong></p><p><strong><code>newSingleThreadExecutor(ThreadFactory threadFactory)</code></strong></p><p><strong><code>newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)</code></strong>：</p><p>这些方法与上述方法类似，不同之处在于可以指定自定义的线程工厂来创建线程。</p></li></ol><p>通过 <code>Executors</code> 类提供的这些静态方法，可以方便地创建不同类型的线程池，根据具体的需求来管理线程池，从而更有效地管理和执行多线程任务。</p><p>要关闭线程池，可以调用 <code>ExecutorService</code> 接口的 <code>shutdown()</code> 方法或 <code>shutdownNow()</code> 方法。这两种方法都用于停止接受新的任务，并尝试完成所有已经存在的任务。</p><ol><li><code>shutDown</code> 方法 <ul><li><code>shutdown()</code> 方法是一个温和的关闭方法，它会停止接受新的任务，并允许已经提交的任务（包括等待执行和正在执行的任务）继续执行直到完成。</li><li>调用 <code>shutdown()</code> 方法后，线程池不会立即关闭，而是等待所有任务执行完毕，然后关闭线程池。在关闭过程中，可以通过 <code>isTerminated()</code> 方法判断线程池是否已经关闭，或通过 <code>awaitTermination()</code> 方法等待线程池完全关闭。</li></ul></li><li><code>shutdownNow()</code> 方法： <ul><li><code>shutdownNow()</code> 方法是一个强制关闭方法，它会立即停止接受新的任务，并尝试终止正在执行的任务。</li><li>调用 <code>shutdownNow()</code> 方法后，线程池会立即尝试停止所有正在执行的任务，并返回尚未开始执行的任务列表。</li><li>与 <code>shutdown()</code> 方法不同，<code>shutdownNow()</code> 方法不会等待已经提交的任务执行完毕，而是立即关闭线程池。</li></ul></li></ol><p>需要注意的是，调用 <code>shutdown()</code> 或 <code>shutdownNow()</code> 方法后，线程池就不能再提交新的任务了。因此，在调用这些方法之后，应该确保已经提交的任务能够被正确执行完毕，否则可能会导致任务丢失或者资源泄漏的问题。</p><h3 id="_1-6-3-控制任务组" tabindex="-1"><a class="header-anchor" href="#_1-6-3-控制任务组"><span>1.6.3 控制任务组</span></a></h3><p>通过上面的线程池和执行器，能够控制整个任务组的工作。</p><p>主要使用 <code>java.util.concurrent.ExecutorService</code> 类和 <code>java.util.concurrent.ExecutorCompletionService</code> 类中提供的方法。</p><h3 id="_1-6-4-fork-join-框架" tabindex="-1"><a class="header-anchor" href="#_1-6-4-fork-join-框架"><span>1.6.4 fork-join 框架</span></a></h3><p>Fork-Join 框架是 Java 并发包中提供的一个用于并行计算的框架，主要用于解决分治算法中的任务并行化问题。它的设计目标是让开发者能够轻松地编写并行化的程序，利用多核处理器的性能优势来加速任务的执行。</p><p>Fork-Join 框架的核心概念包括以下几点：</p><ol><li><strong>分治思想</strong>：Fork-Join 框架基于分治算法，将大任务划分为多个小任务，然后并行地执行这些小任务，最后合并各个子任务的结果得到最终结果。这种分治思想非常适合于并行计算，能够充分利用多核处理器的性能。</li><li><strong>工作窃取</strong>：Fork-Join 框架通过工作窃取（Work Stealing）算法来实现任务的调度和执行。每个线程都维护一个双端队列（Deque），当自己的队列为空时，会去其他线程的队列中窃取任务执行，从而保持线程的利用率。</li><li><strong>任务分解</strong>：Fork-Join 框架中的任务可以通过递归的方式进行分解，每次分解任务时，会判断任务的规模是否足够小，如果足够小则直接执行，否则继续分解任务直到满足执行条件。</li><li><strong>核心类</strong>：Fork-Join 框架的核心类是 <code>ForkJoinPool</code>、<code>ForkJoinTask</code> 和 <code>RecursiveTask</code>。<code>ForkJoinPool</code> 是线程池的实现类，用于管理线程的创建和销毁；<code>ForkJoinTask</code> 是任务的抽象类，定义了执行任务的方法；<code>RecursiveTask</code> 是递归任务的抽象类，继承自 <code>ForkJoinTask</code>，用于表示可以递归分解的任务。</li></ol><p>Fork-Join 框架的使用步骤通常包括以下几点：</p><ol><li>继承 <code>RecursiveTask</code> 类，实现自定义的递归任务。</li><li>在任务的 <code>compute()</code> 方法中，实现任务的逻辑，并根据任务的规模决定是否继续分解任务或直接执行任务。</li><li>创建 <code>ForkJoinPool</code> 对象，将任务提交到线程池中执行。</li><li>获取任务的执行结果，并进行合并操作得到最终结果。</li></ol><p>Fork-Join 框架提供了一种简单而高效的方式来实现任务的并行化，特别适用于处理递归和分治算法的场景。它能够充分利用多核处理器的性能优势，加速任务的执行，从而提高程序的性能和响应性。</p><h2 id="_1-7-异步计算" tabindex="-1"><a class="header-anchor" href="#_1-7-异步计算"><span>1.7 异步计算</span></a></h2><p>异步计算主要使用 <code>CompletableFuture</code> 类。</p><p>需要注册一个回调函数，一旦结果可用，就会在某个线程中利用该结果调用这个回调。</p><p>这个类提供了一个机制，可以将多个异步任务组合成一个处理流水线。</p><h2 id="_1-8-进程" tabindex="-1"><a class="header-anchor" href="#_1-8-进程"><span>1.8 进程</span></a></h2><h3 id="_1-8-1-创建和启动进程" tabindex="-1"><a class="header-anchor" href="#_1-8-1-创建和启动进程"><span>1.8.1 创建和启动进程</span></a></h3><p><code>ProcessBuilder</code> 类和 <code>Process</code> 类是 Java 中用于创建和管理外部进程的两个重要类。</p><p><strong><code>ProcessBuilder</code></strong>：</p><ul><li><code>ProcessBuilder</code> 类用于创建一个外部进程的构造器。它提供了一种更灵活的方式来创建和启动外部进程，可以设置进程的命令、参数、工作目录等信息。</li><li>使用 <code>ProcessBuilder</code> 可以创建一个进程构造器，并通过 <code>command()</code> 方法设置进程的命令和参数，然后调用 <code>start()</code> 方法启动进程。</li></ul><p><strong><code>Process</code></strong>：</p><ul><li><code>Process</code> 类表示一个正在运行的外部进程。通过 <code>Process</code> 对象，可以获取进程的输入输出流，等待进程执行完成，获取进程的返回值等信息。</li><li>使用 <code>Process</code> 对象可以执行各种操作，如读取进程的标准输出、标准错误输出，发送输入给进程等。</li></ul><p>主进程可以和这些进程通过管道通信。</p><h3 id="_1-8-2-进程句柄" tabindex="-1"><a class="header-anchor" href="#_1-8-2-进程句柄"><span>1.8.2 进程句柄</span></a></h3><p>在 Java 中，通过 <code>Process</code> 对象可以获取外部进程的句柄。进程句柄通常用于在操作系统级别标识和管理进程，但在 Java 中，<code>Process</code> 对象并不直接提供获取进程句柄的方法。不过，可以通过一些间接的方式来获取进程的句柄，具体取决于操作系统和平台的不同。</p><p>在 Linux 和 Unix-like 系统中，可以使用 <code>/proc</code> 文件系统来获取进程句柄。每个进程都有一个相应的目录，其中包含了该进程的各种信息，包括进程 ID、状态等。通过读取相应的目录，可以获取进程的句柄。</p><p>在 Windows 系统中，可以使用 <code>ProcessHandle</code> 类来获取进程句柄。<code>ProcessHandle</code> 类是 Java 9 中新增的一个类，用于表示和操作本地进程。</p><p>获取 <code>ProcessHandle</code> 有四种方法：</p><ol><li>给定一个 <code>Process</code> 对象 <code>p</code> 可以通过 <code>p.toHandle()</code> 方法得到他的句柄。</li><li>给定进程 <code>pid</code> 可以通过 <code>ProcessHandle.of(pid)</code> 方法得到句柄。</li><li>通过 <code>Process.current</code> 方法得到运行这个 Java 虚拟机的进程的句柄。</li><li>通过 <code>ProcessHandle.allProcesses()</code> 可以得到所有对当前进程可见的操作系统进程的 <code>Stream&lt;ProcessHandle&gt;</code> 对象。</li></ol><p>通过句柄可以得到进程的相关信息。</p><h3 id="_1-8-3-僵尸进程和孤儿进程" tabindex="-1"><a class="header-anchor" href="#_1-8-3-僵尸进程和孤儿进程"><span>1.8.3 僵尸进程和孤儿进程</span></a></h3><p>在使用 <code>ProcessBuilder</code> 类和 <code>Process</code> 类创建和管理外部进程时，通常不会出现僵尸进程和孤儿进程的情况，因为 Java 在这方面提供了良好的处理机制。</p><ol><li><strong>僵尸进程</strong>： <ul><li>僵尸进程是指一个已经终止但是其父进程没有调用 <code>wait()</code> 或 <code>waitpid()</code> 来获取其状态的子进程。</li><li>在 Java 中，当一个 <code>Process</code> 对象创建的外部进程终止时，<code>Process</code> 对象会自动处理并清理相关资源，不会留下僵尸进程。</li></ul></li><li><strong>孤儿进程</strong>： <ul><li>孤儿进程是指父进程退出了，但是子进程还在运行的情况。</li><li>在 Java 中，如果创建的外部进程是由 Java 虚拟机启动的，那么这个外部进程的父进程就是 JVM 进程。当 JVM 进程退出时，它会自动终止所有由它启动的子进程，因此不会出现孤儿进程的情况。</li></ul></li></ol><p>总的来说，Java 提供了良好的进程管理机制，使用 <code>ProcessBuilder</code> 类和 <code>Process</code> 类创建和管理外部进程时，通常不会出现僵尸进程和孤儿进程的情况。</p></div></div><footer class="page-meta"><div class="meta-item edit-link"><span class="xicon-container left meta-item-label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 32 32" class="xicon-icon" style="width:20px;height:20px;font-size:20px;color:inherit;"><path d="M2 26h28v2H2z" fill="currentColor"></path><path d="M25.4 9c.8-.8.8-2 0-2.8l-3.6-3.6c-.8-.8-2-.8-2.8 0l-15 15V24h6.4l15-15zm-5-5L24 7.6l-3 3L17.4 7l3-3zM6 22v-3.6l10-10l3.6 3.6l-10 10H6z" fill="currentColor"></path></svg><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->Edit this page<!--]--></span></span></div><div class="meta-item last-updated"><span class="xicon-container left meta-item-label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 32 32" class="xicon-icon" style="width:20px;height:20px;font-size:20px;color:inherit;"><path d="M26 4h-4V2h-2v2h-8V2h-2v2H6c-1.1 0-2 .9-2 2v20c0 1.1.9 2 2 2h20c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 22H6V12h20v14zm0-16H6V6h4v2h2V6h8v2h2V6h4v4z" fill="currentColor"></path></svg><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->Last Updated 2024/9/22 16:35:40<!--]--></span></span></div></footer><!----><!----></div><div class="page-catalog-container"><h5 class="tip">ON THIS PAGE</h5><ul><!--[--><!--[--><li class="page-catalog-menu-depth_2"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-1-什么是线程" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.1. 什么是线程"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.1. 什么是线程<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_2"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-2-线程状态" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.2. 线程状态"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.2. 线程状态<!--]--></span></span><!--[--><!--]--></a></li><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-2-1-新建线程" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.2.1. 新建线程"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.2.1. 新建线程<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-2-2-可运行线程" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.2.2. 可运行线程"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.2.2. 可运行线程<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-2-3-阻塞和等待线程" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.2.3. 阻塞和等待线程"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.2.3. 阻塞和等待线程<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-2-4-终止线程" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.2.4. 终止线程"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.2.4. 终止线程<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--]--><!--[--><li class="page-catalog-menu-depth_2"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-3-线程属性" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.3 线程属性"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.3 线程属性<!--]--></span></span><!--[--><!--]--></a></li><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-3-1-中断线程" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.3.1 中断线程"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.3.1 中断线程<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-3-2-守护线程" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.3.2 守护线程"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.3.2 守护线程<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-3-3-线程名" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.3.3 线程名"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.3.3 线程名<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-3-4-未捕获异常的处理器" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.3.4 未捕获异常的处理器"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.3.4 未捕获异常的处理器<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-3-5-线程优先级" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.3.5 线程优先级"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.3.5 线程优先级<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--]--><!--[--><li class="page-catalog-menu-depth_2"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-4-同步" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.4 同步"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.4 同步<!--]--></span></span><!--[--><!--]--></a></li><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-4-1-锁对象" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.4.1 锁对象"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.4.1 锁对象<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-4-2-条件对象" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.4.2 条件对象"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.4.2 条件对象<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-4-3-示例代码" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.4.3 示例代码"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.4.3 示例代码<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-4-4-synchronized-关键字" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.4.4 synchronized 关键字"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.4.4 synchronized 关键字<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-4-5-监视器概念" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.4.5 监视器概念"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.4.5 监视器概念<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-4-6-volatile-字段" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.4.6 volatile 字段"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.4.6 volatile 字段<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-4-7-final-变量" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.4.7 final 变量"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.4.7 final 变量<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-4-8-原子性" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.4.8 原子性"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.4.8 原子性<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-4-9-死锁" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.4.9 死锁"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.4.9 死锁<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-4-10-线程局部变量" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.4.10 线程局部变量"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.4.10 线程局部变量<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--]--><!--[--><li class="page-catalog-menu-depth_2"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-5-线程安全的集合" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.5 线程安全的集合"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.5 线程安全的集合<!--]--></span></span><!--[--><!--]--></a></li><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-5-1-阻塞队列" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.5.1 阻塞队列"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.5.1 阻塞队列<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-5-2-映射-集-队列" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.5.2 映射&amp;集&amp;队列"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.5.2 映射&amp;集&amp;队列<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-5-3-并行数组算法" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.5.3 并行数组算法"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.5.3 并行数组算法<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--]--><!--[--><li class="page-catalog-menu-depth_2"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-6-任务和线程池" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.6 任务和线程池"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.6 任务和线程池<!--]--></span></span><!--[--><!--]--></a></li><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-6-1-callable-和-future" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.6.1 Callable 和 Future"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.6.1 Callable 和 Future<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-6-2-执行器" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.6.2 执行器"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.6.2 执行器<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-6-3-控制任务组" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.6.3 控制任务组"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.6.3 控制任务组<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-6-4-fork-join-框架" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.6.4 fork-join 框架"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.6.4 fork-join 框架<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--]--><!--[--><li class="page-catalog-menu-depth_2"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-7-异步计算" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.7 异步计算"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.7 异步计算<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_2"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-8-进程" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.8 进程"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.8 进程<!--]--></span></span><!--[--><!--]--></a></li><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-8-1-创建和启动进程" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.8.1 创建和启动进程"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.8.1 创建和启动进程<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-8-2-进程句柄" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.8.2 进程句柄"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.8.2 进程句柄<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/Java/bingfa.html#_1-8-3-僵尸进程和孤儿进程" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="1.8.3 僵尸进程和孤儿进程"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:inherit;font-size:14px;"><!--[-->1.8.3 僵尸进程和孤儿进程<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--]--><!--]--></ul></div></main><!--]--></div><!--[--><!----><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-B51tXhJU.js" defer></script>
  </body>
</html>
